그리디 알고리즘은 일련의 선택을 통해 문제에 대한 최적해를 구합니다. 각각의 선택에서, 알고리즘은 그 순간에 최선으로 보이는 선택을 합니다. 이러한 전략이 항상 최적해를 찾는다고 할 수는 없지만, 활동 선택 문제에서 보았듯이, 가끔은 최적해를 찾을 수 있습니다. 이번 절에서는 그리디 알고리즘의 일반적인 특징에 대해서 알아볼 것입니다.

16.1 절에서 살펴본 그리디 알고리즘을 만드는 과정은 일반적인 경우보다 조금 더 복잡했습니다. 그 과정은 다음과 같은 단계들을 거쳤습니다:
1. 문제에 대한 최적의 하위 구조를 결정하고,
2. 재귀적으로 표현되는 해를 만들고,
3. '탐욕적인' 선택을 하면 하나의 하위 문제만 남는 다는 것을 보이고,
4. '탐욕적인' 선택을 하는 것이 항상 안전함을 증명하고,
5. '탐욕적인' 전략을 재귀 함수로 구현하고,
6. 재귀 함수를 반복문을 통해 다시 구현했습니다.

위의 단계를 거치면서, 그리디 알고리즘의 기초가 되는 [[Dynamic Programming|동적 프로그래밍]]을 자세히 살펴보았습니다. 예를 들어, 활동 선택 문제에서 $i$와 $j$가 모두 변하는 하위 문제인 $S_{ij}$를 정의했습니다. 그리고 '탐욕적인' 선택을 하면 항상 하위 문제를 $S_k$ 형식으로 제한할 수 있었습니다.

대안으로, '탐욕적인' 선택을 이용해서 그 선택이 해결해야 할 하나의 하위 문제만 남기도록 최적의 하위 구조를 구성할 수 있습니다. 활동 선택 문제에서 $S_{ij}$가 아닌 $S_k$를 이용해서 하위 문제를 정의한 것이 바로 그것입니다. 그리고 다음의 '탐욕적인' 선택과 남아 있는 $S_m$에 대한 최적의 해를 결합해서 $S_k$에 대한 최적해를 찾을 수 있다는 것을 증명할 수 있었습니다. 더 일반적으로는, 다음과 같은 단계에 따라 그리디 알고리즘을 설계합니다:
1. 주어진 최적화 문제를 하나의 선택을 하고 나면 해결해야 할 하나의 부분 문제가 남는 형태로 변환합니다.
2. '탐욕적인' 선택이 항상 안전하고, 그 선택으로 기존의 문제에 대한 최적해를 찾을 수 있음을 증명합니다.
3. '탐욕적인' 선택을 한 후 남은 부분 문제가 최적의 하위 구조를 가진다는 것을 증명합니다. 다시 말하면, 하위 문제에 대한 최적의 해와 '탐욕적인' 선택을 결합하면 원래 문제에 대한 최적해에 도달함을 보여줍니다.

다음 절에서 이 과정에 대해 좀 더 알아보겠지만, 거의 모든 그리디 알고리즘 아래에는 더 복잡한 동적 프로그래밍 해법이 존재합니다.




#Algorithm #GreedyAlgorithm