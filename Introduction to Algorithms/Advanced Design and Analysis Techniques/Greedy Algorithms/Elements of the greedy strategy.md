그리디 알고리즘은 일련의 선택을 통해 문제에 대한 최적해를 구합니다. 각각의 선택에서, 알고리즘은 그 순간에 최선으로 보이는 선택을 합니다. 이러한 전략이 항상 최적해를 찾는다고 할 수는 없지만, 활동 선택 문제에서 보았듯이, 가끔은 최적해를 찾을 수 있습니다. 이번 절에서는 그리디 알고리즘의 일반적인 특징에 대해서 알아볼 것입니다.

16.1 절에서 살펴본 그리디 알고리즘을 만드는 과정은 일반적인 경우보다 조금 더 복잡했습니다. 그 과정은 다음과 같은 단계들을 거쳤습니다:
1. 문제에 대한 최적의 하위 구조를 결정하고,
2. 재귀적으로 표현되는 해를 만들고,
3. '탐욕적인' 선택을 하면 하나의 하위 문제만 남는 다는 것을 보이고,
4. '탐욕적인' 선택을 하는 것이 항상 안전함을 증명하고,
5. '탐욕적인' 전략을 재귀 함수로 구현하고,
6. 재귀 함수를 반복문을 통해 다시 구현했습니다.

위의 단계를 거치면서, 그리디 알고리즘의 기초가 되는 [[Dynamic Programming|동적 프로그래밍]]을 자세히 살펴보았습니다. 예를 들어, 활동 선택 문제에서 $i$와 $j$가 모두 변하는 하위 문제인 $S_{ij}$를 정의했습니다. 그리고 '탐욕적인' 선택을 하면 항상 하위 문제를 $S_k$ 형식으로 제한할 수 있었습니다.

대안으로, '탐욕적인' 선택을 이용해서 그 선택이 해결해야 할 하나의 하위 문제만 남기도록 최적의 하위 구조를 구성할 수 있습니다. 활동 선택 문제에서 $S_{ij}$가 아닌 $S_k$를 이용해서 하위 문제를 정의한 것이 바로 그것입니다. 그리고 다음의 '탐욕적인' 선택과 남아 있는 $S_m$에 대한 최적의 해를 결합해서 $S_k$에 대한 최적해를 찾을 수 있다는 것을 증명할 수 있었습니다. 더 일반적으로는, 다음과 같은 단계에 따라 그리디 알고리즘을 설계합니다:
1. 주어진 최적화 문제를 하나의 선택을 하고 나면 해결해야 할 하나의 부분 문제가 남는 형태로 변환합니다.
2. '탐욕적인' 선택이 항상 안전하고, 그 선택으로 기존의 문제에 대한 최적해를 찾을 수 있음을 증명합니다.
3. '탐욕적인' 선택을 한 후 남은 부분 문제가 최적의 하위 구조를 가진다는 것을 증명합니다. 다시 말하면, 하위 문제에 대한 최적의 해와 '탐욕적인' 선택을 결합하면 원래 문제에 대한 최적해에 도달함을 보여줍니다.

다음 절에서 이 과정에 대해 좀 더 알아보겠지만, 거의 모든 그리디 알고리즘 아래에는 더 복잡한 동적 프로그래밍 해법이 존재합니다.

어떤 최적화 문제를 그리디 알고리즘을 이용해 해결할 수 있는지를 판단하는 데에는 *탐욕 선택 속성*과 *최적 하위 구조*라는 두 가지 주요 요소를 고려해야 합니다. 주어진 문제에 이 요소가 있음을 증명할 수 있다면, 그리디 알고리즘을 사용하여 그 문제를 해결할 가능성이 높습니다.

###### 탐욕 선택 속성
첫 번째 요소인 탐욕 선택 속성은, 부분적으로 최적인 선택(탐욕 선택)을 통해 전체적으로 최적인 해결책을 구성하는 성질을 말합니다. 다시 말하면, 어떤 선택을 할 지 고려할 때, 부분 문제의 결과를 고려하지 않고 현재 문제에서 가장 좋아 보이는 선택을 합니다.

여기에서 그리디 알고리즘과 동적 프로그래밍의 차이가 발생합니다. 동적 프로그래밍에서는 각 단계에서 선택을 하지만, 그 선택은 일반적으로 부분 문제들의 해에 따라 결정됩니다. 결과적으로 동적 프로그래밍 문제는 작은 문제부터 해결한 뒤에 큰 문제를 해결하는 방식으로 진행됩니다.(코드에서 하향식으로 문제를 해결하는 것과는 개념이 조금 다릅니다. 코드에서 하향식으로 작동하더라도, 선택을 하기 전에 부분 문제를 먼저 해결해야 한다는 점은 변하지 않습니다.) 그리디 알고리즘에서는 현재 순간에 가장 좋아 보이는 선택을 하고, 남은 부분 문제를 해결합니다. 그리디 알고리즘이 내리는 선택은 지금까지의 선택에 의존할 수 있지만, 미래의 선택이나 부분 문제의 해에 의존할 수 없습니다. 동적 프로그래밍에서는 첫 번째 선택을 하기 전에 부분 문제를 해결하는 반면, 그리디 알고리즘은 어떤 부분 문제도 해결하기 전에 첫 번째 선택을 합니다. 동적 프로그래밍과는 다르게 그리디 알고리즘은 보통 하향으로 진행되고, 하나의 탐욕 선택을 하고 나면 주어진 문제를 더 작은 문제로 만듭니다.

물론, 각 단계에서 탐욕 선택이 전체적으로 최적의 해결책을 제공한다는 것을 증명합니다. 일반적으로 증명은, 어떤 부분 문제에 대한 전역적인 최적해를 고려합니다. 그리고 다른 선택 대신 탐욕 선택을 적용해서, 비슷하면서 더 작은 하위 문제를 해결하도록 합니다.

탐욕 선택은 선택에 고려되는 대상이 많은 때 더 효율적일 수 있습니다. 활동 선택 문제에서 활동들을 종료 시간이 증가하는 순서로 정렬해 둔 것은 각 활동을 한 번만 검토할 수 있게 했습니다. 


#Algorithm #GreedyAlgorithm