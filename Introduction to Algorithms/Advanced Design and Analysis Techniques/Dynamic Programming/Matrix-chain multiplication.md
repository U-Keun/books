다음으로 볼 동적 프로그래밍 알고리즘 예제는 행렬의 연쇄 곱에 관한 문제입니다. $n$개의 행렬 $A_1, A_2, \dots, A_n$을 다음의 식과 같이 계산하는 상황을 생각해 보겠습니다:
$$A_1 A_2 \cdots A_n.$$
행렬의 곱 연산은 결합 법칙이 성립하기 때문에 괄호를 이용해 행렬을 적당히 묶어서 계산하는 순서를 지정할 수 있습니다. 예를 들어, 4개의 행렬 $A_1, A_2, A_3, A_4$에 대해서는 연속 곱을 계산하는 서로 다른 방법이 5가지 있습니다:
$$\begin{align}
(A_1(A_2(A_3 A_4))),\\
(A_1((A_2 A_3)A_4)),\\
((A_1 A_2)(A_3 A_4)),\\
((A_1(A_2 A_3))A_4),\\
(((A_1 A_2)A_3)A_4).
\end{align}$$
위와 같은 여러 가지 방법 중 어떤 순서로 행렬을 곱해야 행렬의 연속 곱을 계산하는 비용을 최적화할 수 있을지 알아볼 것입니다. 먼저 두 개의 행렬의 곱에 대한 계산 비용을 생각해 보겠습니다. 행렬 곱에 대한 표준 알고리즘은 다음의 의사 코드에 나와있습니다.
```pseudo
Matrix-Multiply(A, B)
if A.columns != B.rows
	error "incompatible dimensions"
else let C be a ne A.rows * B.columns matrix
	for i = 1 to A.rows \\ p번
		for j = 1 to B.columns \\ r번
			C[i][j] = 0
			for k = 1 to A.columns \\ q번
				C[i][j] = C[i][j] + A[i][k] * B[k][j]
	return C
```

두 행렬 $A$, $B$에 대해 $AB$를 계산하려면 행렬 $A$의 열의 개수와 행렬 $B$의 해의 개수가 같아야 합니다.[^1] $A$가 $p \times q$ 행렬이고, $B$가 $q \times r$ 행렬이라고 가정하면, 위의 함수로 반환되는 $C$는 $p \times r$ 행렬입니다. 그리고 $C$를 계산하는데 필요한 스칼라 곱은 $pqr$번 수행됩니다(위의 의사 코드 9번째 줄). 이 문제에서는 이렇게 계산되는 스칼라 곱의 횟수를 비용으로 바라볼 것입니다.

여러 개의 행렬을 곱할 때 비용이 어떻게 달라지는지 예제를 통해 알아봅시다. 세 개의 행렬 $A_1$, $A_2$, $A_3$가 각각 $10\times100$, $100\times5$, $5\times50$ 행렬이고, $A_1 A_2 A_3$를 계산하는 상황을 생각해 봅시다. $((A_1 A_2)A_3)$ 순서로 계산하면 먼저 $10\cdot100\cdot5=5000$번의 스칼라 곱을 수행하고, 그 다음 $10\cdot5\cdot50=2500$번의 스칼라 곱을 수행합니다. 즉, 총 $7500$번의 스칼라 곱을 수행합니다. 비슷하게 $(A_1(A_2 A_3))$ 순서로 계산할 때 수행되는 스칼라 곱의 횟수를 계산하면 $75000$번입니다. 이 관점에서는 첫 번째 방식이 10배 정도 빠르다고 볼 수 있습니다.

위의 *행렬 연속 곱 문제*는 다음과 같이 서술됩니다: $n$개의 행렬 $A_1, A_2, \dots, A_n$이 주어지고, 각 $A_i$가 $p_{i - 1} \times p_i$ 행렬일 때 연속 곱 $A_1 A_2 \cdots A_n$에서 스칼라 곱의 횟수를 최소화하는 행렬 곱 순서.

이 문제에서는 가장 낮은 비용으로 행렬을 곱하는 방법을 찾는 것이기 때문에 행렬을 주어진 행렬을 실제로 곱할 필요는 없습니다. 그리고 일반적으로 이 최적 순서를 결정하는 데 투자된 시간은 행렬 곱셈을 실제로 수행할 때 나중에 절약된 시간보다 더 많습니다.
###### 순서를 정하는 경우의 수
행렬 연속 곱 문제를 동적 프로그래밍으로 풀기 전에 가능한 모든 순서를 고려하는 것이 효율적이지 않은 방법임을 증명해보겠습니다. 먼저 $n$개의 행렬을 괄호를 이용해서 계산 순서를 정하는 경우의 수를 $P(n)$이라고 하겠습니다. $n = 1$인 경우에는 행렬이 하나 뿐이므로 $P(1) = 1$입니다. $n\ge 2$인 경우, 두 부분 연속 곱이 곱해진 형태로 생각할 수 있고, 각각의 부분 곱에 대해서는 $P(k)$, $P(n - k)$로 계산될 수 있습니다. 이것을 점화식으로 표현하면 다음과 같습니다.
$$
P(n)= \begin{cases}
1 &\ \mbox{if } n = 1,\\
\displaystyle\sum_{k = 1}^{n - 1} P(k)P(n - k) &\ \mbox{if } n\ge2.
\end{cases}
$$
실제로 수열 $P(n)$은 *Catalan 수*입니다. 이것은 $\Omega(4^n / n^{3/2})$의 점근식을 가진다는 것이 알려져 있고, 연습 문제로 $\Omega(2^n)$임을 증명해봐도 좋습니다. 어쨌든 $P(n)$은 $n$의 지수 함수 정도로 증가하기 때문에 전체 경우의 수를 고려해서 행렬 곱의 순서를 고려하는 것은 효율적이지 않습니다.
###### 동적 프로그래밍 적용하기
동적 프로그래밍을 이용해서 어떤 순서로 행렬을 곱할 지 결정해 봅시다. 이번 장의 앞부분에서 언급했던 네 단계를 따라 진행해보겠습니다:
1. 최적해의 구조를 정의합니다.
2. 최적해의 값을 재귀적으로 정의합니다.
3. 최적해의 값을 계산합니다.
4. 계산된 정보로부터 최적해를 구축합니다.
이 순서로 문제에 각각의 단계를 어떻게 적용하는지 살펴봐야 합니다.
###### 1. 최적 순서의 구조
동적 프로그래밍의 패러다임을 사용하려면 하위 문제의 최적해를 이용해서 문제를 해결할 수 있도록 최적해를 구하기 위해 사용되는 구조를 잘 정의해야 합니다. 행렬 연속 곱 문제에서는 그것을 다음과 같이 정의할 수 있습니다:

먼저, $i\le j$에 대해, $A_i A_{i + 1} \cdots A_j$를 계산할 때 $i \neq j$ 라면 $i\le k < j$인 $k$에 대해 연속 곱을  $A_i A_{i + 1} \cdots A_k$와 $A_k A_{k + 1} \cdots A_j$로 나눌 수 있습니다. 그러면 $A_i A_{i + 1} \cdots A_j$에서 수행되는 스칼라 곱의 횟수는 $A_i A_{i + 1} \cdots A_k$에서 수행되는 스칼라 곱의 횟수와 $A_k A_{k + 1} \cdots A_j$에서 수행되는 스칼라 곱의 횟수의 합입니다. 그리고 $A_i A_{i + 1}\cdots A_k$(또는 $A_{k + 1}\cdots A_j$)에서 가장 적은 스칼라 곱의 횟수를 가지는 곱셈 순서는 $A_i\cdots A_j$에서 수행되는 전체 스칼라 곱의 횟수를 계산할 때, $A_k$와 $A_{k + 1}$ 사이가 괄호로 구분되는 경우에, 사용돼야 합니다.

위의 관찰을 이용해서 $A_i A_{i + 1} \cdots A_j$에 대한 최적해를 구하는 문제를 $i\le k < j$인 $k$에 대해 두 개의 하위 문제인 $A_i A_{i + 1} \cdots A_k$와 $A_k A_{k + 1} \cdots A_j$의 최적해를 구하는 문제로 나눌 수 있습니다. 그러면 나눌 수 있는 각각의 경우에 대해 하위 문제의 최적해들을 종합해서 문제를 해결할 수 있습니다.
###### 2. 점화식
다음으로 최적해의 값에 해당하는 계산 비용을 하위 문제의 최적해를 이용해 재귀적으로 정의해야 합니다. $m[i, j]$를 $A_i\cdots A_j$를 계산하는 데 필요한 스칼라 곱의 최소 횟수라고 하겠습니다; 기존의 문제에서는 $m[1, n]$을 구하는 것이 됩니다.

먼저, $i = j$인 경우에는 스칼라 곱이 수행되지 않으므로 $m[i,i]=0$입니다. $i\le k <j$인 $k$에 대해, $m[i,j]$는 $A_i \cdots A_k$에 대응되는 $m[i,k]$와 $A_{k + 1}\cdots A_j$에 대응되는 $m[k + 1, j]$를 사용해서 표현할 수 있습니다. 여기서 $A_i \cdots A_k$는 $p_{i - 1} \times p_k$ 행렬이고, $A_{k + 1}\cdots A_{j}$는 $p_k\times p_j$ 행렬이므로 $p_{i - 1} p_k p_j$번 만큼 스칼라 곱이 수행됩니다. 이것을 식으로 표현하면 다음과 같습니다:
$$m[i,j] = m[i,k] + m[k + 1,j] + p_{i - 1}p_k p_j.$$
이 식은 $k$가 주어졌을 때 유효합니다. $k$는 $i, i+1, \dots, j-1$인 경우에 대해 고려되어야 하므로 점화식은 다음과 같이 정의됩니다:
$$
m[i,j] = 
\begin{cases}
0 &\mbox{ if } i = j,
\\
\displaystyle\min_{i \le k < j} \{m[i,k] + m[k + 1,j] + p_{i - 1}p_k p_j\} &\mbox{ if } i < k.
\end{cases}
$$
이 점화식은 스칼라 곱의 횟수의 최솟값만 구할 수 있기 때문에, 그 최솟값이 구해지는 경우를 구하기 위해서는 그 정보를 저장해야 합니다. 그것을 위해 $s[i,j]$를 $A_i \cdots A_j$에서 스칼라 곱이 최소가 되도록 나누는 부분, 즉, $k$가 저장되도록 정의합니다. 
###### 최적 비용 계산
위에서 정의한 점화식을 이용하면 알고리즘을 어렵지 않게 구현할 수 있습니다. 물론, [[Rod cutting|막대 자르기 문제]]에서 보았듯이, 점화식대로 재귀적으로 작동하는 알고리즘을 구현하면 지수 함수 정도의 시간이 걸릴 수 있기 때문에, 한 번 계산된 하위 문제에 대해서는 다시 계산하지 않도록 값을 저장할 것입니다. 다음의 의사 코드는 상향식 동적 프로그래밍 방식으로 구현한 최적 비용 계산 코드입니다.
```pseudo
Matrix-Chain-Order(p)
n = p.length - 1
let m[1..n,1..n] and s[1..n-1,2..n] be new tables
for i = 1 to n
	m[i,i] = 0
for l = 2 to n
	for i = 1 to n - l + 1
		j = i + l - 1
		m[i,j] = ∞
		for k = i to j - 1
			q = m[i,k] + m[k + 1,j] + p[i - 1] * p[k] * p[j]
			if q < m[i,j]
				m[i,j] = q
				s[i,j] = k
return m ans s
```

입력으로 주어지는 배열 `p`는 길이가 `n + 1`이고, 각 행렬의 크기를 `p[i - 1] * p[i]`로 나타냅니다(`i`는 `1`부터 `n`). `m`과 `s`는 값의 저장에 사용되는 2차원 배열입니다. 위의 점화식이 적용된 것을 확인할 수 있습니다.

- 백준 문제
	- [행렬 곱셈 순서](https://www.acmicpc.net/problem/11049)
	- [행렬 곱셈 순서 4](https://www.acmicpc.net/problem/25683)

 #Algorithm #DP

[^1]: 이런 경우 두 행렬 $A$, $B$가 *compatible*하다고 부릅니다.