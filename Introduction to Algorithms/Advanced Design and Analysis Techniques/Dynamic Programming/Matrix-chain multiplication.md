다음으로 볼 동적 프로그래밍 알고리즘 예제는 행렬의 연쇄 곱에 관한 문제입니다. $n$개의 행렬 $A_1, A_2, \dots, A_n$을 다음의 식과 같이 계산하는 상황을 생각해 보겠습니다:
$$A_1 A_2 \cdots A_n.$$
행렬의 곱 연산은 결합 법칙이 성립하기 때문에 괄호를 이용해 행렬을 적당히 묶어서 계산하는 순서를 지정할 수 있습니다. 예를 들어, 4개의 행렬 $A_1, A_2, A_3, A_4$에 대해서는 연속 곱을 계산하는 서로 다른 방법이 5가지 있습니다:
$$\begin{align}
(A_1(A_2(A_3 A_4))),\\
(A_1((A_2 A_3)A_4)),\\
((A_1 A_2)(A_3 A_4)),\\
((A_1(A_2 A_3))A_4),\\
(((A_1 A_2)A_3)A_4).
\end{align}$$
위와 같은 여러 가지 방법 중 어떤 순서로 행렬을 곱해야 행렬의 연속 곱을 계산하는 비용을 최적화할 수 있을지 알아볼 것입니다. 먼저 두 개의 행렬의 곱에 대한 계산 비용을 생각해 보겠습니다. 행렬 곱에 대한 표준 알고리즘은 다음의 의사 코드에 나와있습니다.
```pseudo
Matrix-Multiply(A, B)
if A.columns != B.rows
	error "incompatible dimensions"
else let C be a ne A.rows * B.columns matrix
	for i = 1 to A.rows \\ p번
		for j = 1 to B.columns \\ r번
			C[i][j] = 0
			for k = 1 to A.columns \\ q번
				C[i][j] = C[i][j] + A[i][k] * B[k][j]
	return C
```

두 행렬 $A$, $B$에 대해 $AB$를 계산하려면 행렬 $A$의 열의 개수와 행렬 $B$의 해의 개수가 같아야 합니다.[^1] $A$가 $p \times q$ 행렬이고, $B$가 $q \times r$ 행렬이라고 가정하면, 위의 함수로 반환되는 $C$는 $p \times r$ 행렬입니다. 그리고 $C$를 계산하는데 필요한 스칼라 곱은 $pqr$번 수행됩니다(위의 의사 코드 9번째 줄). 이 문제에서는 이렇게 계산되는 스칼라 곱의 횟수를 비용으로 바라볼 것입니다.

여러 개의 행렬을 곱할 때 비용이 어떻게 달라지는지 예제를 통해 알아봅시다. 세 개의 행렬 $A_1$, $A_2$, $A_3$가 각각 $10\times100$, $100\times5$, $5\times50$ 행렬이고, $A_1 A_2 A_3$를 계산하는 상황을 생각해 봅시다. $((A_1 A_2)A_3)$ 순서로 계산하면 먼저 $10\cdot100\cdot5=5000$번의 스칼라 곱을 수행하고, 그 다음 $10\cdot5\cdot50=2500$번의 스칼라 곱을 수행합니다. 즉, 총 $7500$번의 스칼라 곱을 수행합니다. 비슷하게 $(A_1(A_2 A_3))$ 순서로 계산할 때 수행되는 스칼라 곱의 횟수를 계산하면 $75000$번입니다. 이 관점에서는 첫 번째 방식이 10배 정도 빠르다고 볼 수 있습니다.

위의 *행렬 연속 곱 문제*는 다음과 같이 서술됩니다: $n$개의 행렬 $A_1, A_2, \dots, A_n$이 주어지고, 각 $A_i$가 $p_{i - 1} \times p_i$ 행렬일 때 연속 곱 $A_1 A_2 \cdots A_n$에서 스칼라 곱의 횟수를 최소화하는 행렬 곱 순서.

이 문제에서는 가장 낮은 비용으로 행렬을 곱하는 방법을 찾는 것이기 때문에 행렬을 주어진 행렬을 실제로 곱할 필요는 없습니다. 그리고 일반적으로 이 최적 순서를 결정하는 데 투자된 시간은 행렬 곱셈을 실제로 수행할 때 나중에 절약된 시간보다 더 많습니다.
###### 순서를 정하는 경우의 수
행렬 연속 곱 문제를 동적 프로그래밍으로 풀기 전에 가능한 모든 순서를 고려하는 것이 효율적이지 않은 방법임을 증명해보겠습니다. 먼저 $n$개의 행렬을 괄호를 이용해서 계산 순서를 정하는 경우의 수를 $P(n)$이라고 하겠습니다. $n = 1$인 경우에는 행렬이 하나 뿐이므로 $P(1) = 1$입니다. $n\ge 2$인 경우, 두 부분 연속 곱이 곱해진 형태로 생각할 수 있고, 각각의 부분 곱에 대해서는 $P(k)$, $P(n - k)$로 계산될 수 있습니다. 이것을 점화식으로 표현하면 다음과 같습니다.
$$
P(n)= \begin{cases}
1 &\ \mbox{if } n = 1,\\
\displaystyle\sum_{k = 1}^{n - 1} P(k)P(n - k) &\ \mbox{if } n\ge2.
\end{cases}
$$
실제로 수열 $P(n)$은 *Catalan 수*입니다. 이것은 $\Omega(4^n / n^{3/2})$의 점근식을 가진다는 것이 알려져 있고, 연습 문제로 $\Omega(2^n)$임을 증명해봐도 좋습니다. 어쨌든 $P(n)$은 $n$의 지수 함수 정도로 증가하기 때문에 전체 경우의 수를 고려해서 행렬 곱의 순서를 고려하는 것은 효율적이지 않습니다.
###### 동적 프로그래밍 적용하기
동적 프로그래밍을 이용해서 어떤 순서로 행렬을 곱할 지 결정해 봅시다. 이번 장의 앞부분에서 언급했던 네 단계를 따라 진행해보겠습니다:
1. 최적해의 구조를 정의합니다.
2. 최적해의 값을 재귀적으로 정의합니다.
3. 최적해의 값을 계산합니다.
4. 계산된 정보로부터 최적해를 구축합니다.
이 순서로 문제에 각각의 단계를 어떻게 적용하는지 살펴봐야 합니다.
###### 1. 최적 순서의 구조
동적 프로그래밍의 패러다임을 사용하려면 하위 문제의 최적해를 이용해서 문제를 해결할 수 있도록 최적해를 구하기 위해 사용되는 구조를 잘 정의해야 합니다. 행렬 연속 곱 문제에서는 그것을 다음과 같이 정의할 수 있습니다:

먼저, $i\le j$에 대해, $A_i A_{i + 1} \cdots A_j$를 계산할 때 $i \neq j$ 라면 $i\le k < j$인 $k$에 대해 연속 곱을  $A_i A_{i + 1} \cdots A_k$와 $A_k A_{k + 1} \cdots A_j$로 나눌 수 있습니다. 그러면 $A_i A_{i + 1} \cdots A_j$에서 수행되는 스칼라 곱의 횟수는 $A_i A_{i + 1} \cdots A_k$에서 수행되는 스칼라 곱의 횟수와 $A_k A_{k + 1} \cdots A_j$에서 수행되는 스칼라 곱의 횟수의 합입니다.



 #Algorithm #DP

[^1]: 이런 경우 두 행렬 $A$, $B$가 *compatible*하다고 부릅니다.