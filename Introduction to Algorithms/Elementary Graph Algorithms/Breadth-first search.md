*너비 우선 탐색*[^Breadth-first search]는 그래프를 탐색하는 간단하지만 중요한 알고리즘입니다. 최소 신장 트리를 구하는 Prim 알고리즘이나 최단 거리를 찾는 Dijkstra 알고리즘에서도 너비 우선 탐색 알고리즘의 아이디어를 사용합니다.

그래프 $G=(V, E)$와 시작 노드 $s$가 주어졌을 때, 너비 우선 탐색은 $s$에서 갈 수 있는 모든 노드를 체계적으로 탐색합니다. 이것은 $s$에서 갈 수 있는 노드까지의 거리를 계산할 수 있고, $s$를 루트 노드로 가지면서 갈 수 있는 노드들을 포함하는 '너비 우선 트리'를 구성할 수도 있습니다. 그 트리에는, $s$에서 갈 수 있는 임의의 노드 $v$에 대해, $s$에서 $v$로 가는 가장 짧은 경로가 저장됩니다. 이 알고리즘은 유향 그래프와 무향 그래프 모두에 대해 작동합니다.

이 알고리즘이 '너비 우선' 이라는 이름이 붙은 이유는 탐색된 노드와 그렇지 않은 노드의 경계를 그 경계의 너비를 확장하는 방식으로 탐색이 수행되기 때문입니다. 이것은 그래프를 탐색할 때 현재 위치한 노드와 직접 연결되어 있는 모든 노드를 먼저 탐색하는 것을 말합니다. 다시 말하면, 노드 $s$로부터 거리가 $k + 1$인 노드를 탐색하기 전에 거리가 $k$인 모든 노드를 먼저 탐색하는 방식입니다.

너비 우선 탐색의 기본적인 과정은 다음과 같이 묘사될 수 있습니다: 그래프의 모든 노드는 흰색인 상태로 탐색이 시작됩니다. 각각의 노드는 회색 또는 검정색으로 칠해질 수 있고, 탐색이 모두 끝나면 모든 노드는 검정색으로 칠해지게 됩니다. 어떤 노드 $u$가 탐색에 의해 방문되었고, $u$의 이웃 노드들이 모두 탐색되지 않았다면 $u$는 회색으로 칠해진 상태입니다. $u$의 모든 이웃 노드가 방문되었다면 $u$는 검정색으로 칠해집니다. 이 방식을 관찰해보면, 간선 $(u, v) \in E$에 대해 $u$가 검정색으로 칠해져 있다면, 노드 $v$는 반드시 회색 또는 검정색으로 칠해져 있어야 합니다. 반면, 회색으로 칠해져 있는 노드는 흰색 노드와 인접해 있을 수 있습니다. 이것으로부터, 회색 노드는 방문한 노드와 그렇지 않은 노드의 경계를 의미하는 것으로 볼 수 있습니다.

너비 우선 탐색은 *너비 우선 트리*[^breadth-first tree]를 구성합니다. 이 트리의 초기 상태는 루트 노드로 시작 노드인 $s$만 가집니다. 이미 방문한 노드 $u$의 인접 리스트를 조회하면서 흰색인 노드 $v$가 발견되면, 그 노드 $v$와 간선 $(u,v)$가 트리에 추가됩니다. 즉, 여기서 노드 $u$는 노드 $v$의 부모 노드가 됩니다. 각각의 노드는 많아야 한 번 방문되기 때문에, 각각의 노드는 많아야 하나의 부모 노드를 가집니다. 이것과 비슷하게 조상 노드 또는 자손 노드에 대한 묘사도 가능합니다.

아래의 의사 코드는 입력으로 그래프 $G=(V, E)$와 시작 노드 $s$가 주어졌을 때 너비 우선 탐색을 진행하는 코드입니다. 주어진 그래프 $G$는 인접 리스트 형식으로 주어진 상황을 가정합니다. 알고리즘에서는 *큐*[^Queue]를 사용해서 회색으로 칠해진 노드를 관리합니다.
```pseudo
BFS(G, s)
for each vertex u in G.V - {s}
	u.color = white
	u.d = ∞
	u.p = NIL
s.color = gray
s.d = 0
s.p = NIL
Q = empty
Enqueue(Q, s)
while Q != empty
	u = Dequeue(Q)
	for each v in G.Adj[u]
		if v.color == white
			v.color = gray
			v.d = u.d + 1
			v.p = u
			Enqueue(Q, v)
	u.color = black
```

코드의 흐름을 따라가보면, 큐 `Q`에는 항상 회색으로 칠해진 노드가 들어있는 것을 확인할 수 있습니다. 그리고 특정 노드 $u$의 이웃 노드들이 모두 회색으로 칠해졌다면, 노드 $u$를 검정색으로 칠합니다. 또한 큐의 *FIFO*[^First-In First Out] 성질 때문에 큐에서 먼저 빠져나오는 노드가 시작 노드 $s$로부터의 거리가 그 뒤의 노드보다 작거나 같다는 것도 확인할 수 있습니다.
###### 분석
그래프 $G = (V,E)$가 주어졌을 때 너비 우선 탐색 알고리즘의 시간 복잡도는 다음과 같이 계산됩니다: 그래프의 모든 노드는 큐에 최대 한 번씩 들어갔다가 나오는 작업이 수행됩니다. 즉, 큐에 추가 및 제거되는 과정은 $O(1)$의 시간 복잡도를 가지므로, 큐를 관리하는 과정의 총 시간 복잡도는 $O(V)$입니다. 그리고 큐에 노드의 추가 여부를 결정할 때 인접 리스트를 조회하게 되는데, 인접 리스트의 조회는 노드가 큐에서 나왔을 때만 수행되므로, 인접 리스트는 최대 한 번 조회됩니다. 각각의 인접 리스트의 길이를 모두 더하면 $\Theta(E)$이므로, 인접 리스트를 조회하는 과정의 시간 복잡도는 $O(E)$입니다. 노드를 흰색으로 지정하거나 부모 노드의 초기 설정 등의 초기화 과정은 $O(V)$ 정도의 시간 복잡도를 가지므로, 너비 우선 탐색의 전체 실행 시간 복잡도는 $O(V + E)$입니다. 즉, 너비 우선 탐색은 인접 리스트 형식으로 주어진 그래프 $G$의 크기에 대한 선형 시간 복잡도를 가집니다.
###### 최단 거리
주어진 그래프 $G = (V,E)$에 대해, 최단 거리 $\delta(s,v)$를 노드 $s$에서 출발하여 $v$까지의 경로 중 간선이 가장 적게 사용된 경우의 간선의 개수(또는 경로의 길이)로 정의하겠습니다; 만약 $s$에서 $v$로 가는 경로가 없다면 $\delta(s, v)=\infty$로 정의합니다. 

의사 코드에서 계산한 최단 경로의 길이 `v.d`가 실제로 최단 거리임을 증명하기 위해서는 다음과 같은 전제(Lemma 22.1, 22.2, 22.3)가 필요합니다.

먼저 그래프의 최단 거리에 관한 기본 전제입니다.

> Lemma 22.1
> 임의의 유향 또는 무향 그래프 $G = (V, E)$와 그래프의 임의의 노드 $s\in V$를 보자. 각각의 간선 $(u,v) \in E$에 대해 다음의 식이 성립한다: $$\delta(s,v)\le\delta(s,u) + 1.$$

> Proof.
> $(u,v)$가 $G$의 간선이므로, $s$에서 $u$로 가는 경로가 있다면 $s$에서 $v$로 가는 경로도 $s$에서 $u$로 가는 경로에 간선 $(u,v)$를 추가하여 만들 수 있다. 다시 말하면, $s$에서 $v$로 가는 최단 경로의 길이는 $s$에서 $u$로 가는 최단 경로의 길이보다 최대 $1$ 만큼 클 수 있다. 이것을 식으로 표현하면 위와 같다. 위의 식은 $s$에서 $u$로 가는 경로가 없는 경우($\delta(s,u)=\infty$)에도 성립한다.

다음으로 `v.d`가 $\delta(s,v)$를 하한으로 가짐을 보이는 전제입니다.

> Lemma 22.2
> 임의의 유향 또는 무향 그래프 $G=(V,E)$에 대해, 시작 노드 $s\in V$에서 너비 우선 탐색을 실행했다고 가정하자. 알고리즘이 종료되면, 각각의 노드 $v\in V$에 대해 `v.d`에 저장된 값은 $\delta(s,v)$보다 작거나 같다.

>Proof.
> 큐에 노드 $v$를 추가하는 과정에 대해 귀납법을 사용하여 증명한다. 


#Graph #BFS