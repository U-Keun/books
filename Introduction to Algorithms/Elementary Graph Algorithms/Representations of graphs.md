임의의 그래프 $G = (V, E)$를 표현하는 방법으로 *인접 리스트*[^adjacency list] 또는 *인접 행렬*[^adjacency matrix]를 사용할 수 있습니다. 두 가지 표현 방법 모두 유향[^directed] 그래프와 무향[^undirected] 그래프에 적용할 수 있습니다. 일반적으로 주어진 그래프가 *성긴*[^sparse] 그래프인 경우에는 인접 리스트를 이용해서 그래프를 표현합니다. 이 책에서 공부하는 대부분의 알고리즘의 입력은 인접 리스트 형식으로 주어진다고 가정합니다. 반면, 인접 행렬 형식은 주어진 그래프가 *빽빽한*[^dense] 그래프이거나 두 노드 사이에 간선이 존재하는지를 빠르게 조회해야 할 때 사용합니다.

그래프 $G = (V, E)$의 인접 리스트 표현은 $|V|$개의 `Adj` 배열로 구성되어 있습니다. 각각의 노드 $u \in V$에 대해, 인접 리스트 $Adj[[u]$는 $(u, v) \in E$를 만족하는 모든 노드 $v$를 포함하고 있습니다. 다시 말하면, 그래프 $G$에서 노드 $u$와 인접한[^1] 모든 노드로 구성되어 있습니다. 유향 그래프의 경우 이것은 간선의 방향을 나타냅니다.

그래프 $G$가 유향 그래프라면, 모든 인접 리스트의 길이의 합은 $|E|$ 입니다.(무향 그래프의 경우에는, 간선이 양방향으로 있는 것으로 고려해야 하기 때문에 $2\cdot |E|$ 입니다.) 인접 리스트 표현은 그래프를 표현하기 위한 메모리가 $O(V + E)$ 정도라는 장점을 가집니다.

인접 리스트 표현은 가중치가 부여된 그래프[^weighted graph]에서도 사용될 수 있습니다. 이것은 그래프의 간선이 가중치 함수[^weight function] $w : E -> \mathbb{R}$ 로 정의된 값이 함께 주어진다는 것을 의미합니다. 간단하게 보자면, $u$의 인접 리스트에, 간선 $(u, v) \in E$에 대해, $w(u, v)$ 값을 함께 저장해두는 것을 의미합니다. 그리고 이것을 응용하여 그래프의 여러 가지 변형에도 인접 리스트 형식을 적용해서 표현할 수 있습니다.

인접 리스트 표현의 단점으로는, 특정 간선이 그래프에 존재하는지 여부를 인접 리스트 $Adj[u]$ 전체를 조회해봐야 알 수 있다는 것입니다. 인접 행렬 표현은 이 부분에 대해서는 최적이지만, 더 많은 메모리를 사용해서 그래프를 표현합니다. 

그래프 $G = (V, E)$의 인접 행렬 표현은, 각 노드가 $1$부터 $|V|$로 인덱싱되어 있다고 가정하고, $|V|\times |V|$ 행렬 $A = (a_{i,j})$를 다음과 같이 정의합니다:
$$
a_{i,j} = \big\{ \begin{aligned}
1 & \mbox{ if } (i, j) \in E,\\
0 & \mbox{ otherwise.}
\end{aligned}
$$

위와 같이 정의된 인접 행렬을 보면, 무향 그래프인 경우에는 간선 $(u, v)$와 $(v, u)$가 같은 간선을 표현하기 때문에 대칭 행렬이 됩니다. 그래서 어떤 알고리즘에서는 인접 행렬을 대각선 요소 위쪽만 보는 것으로 메모리 사용을 줄이기도 합니다.

그래프의 인접 리스트 표현과 마찬가지로, 인접 행렬 표현도 가중치가 있는 그래프를 표현할 수 있습니다. 이것은 $a_{u, v} = w(u, v)$로 값을 저장하고, 간선이 없는 경우에는 알고리즘의 편의상 $0$이나 $\infty$에 대응되는 숫자를 저장하기도 합니다.

위에서 언급했었지만, 인접 리스트 표현이 인접 행렬 표현보다 공간 효율을 챙길 수는 있지만, 인접 행렬은 

#Graph

[^sparse]: 간선의 개수 $|E|$가 노드의 개수의 제곱 $|V|^2$과의 차이가 큰 경우
[^dense]: 간선의 개수 $|E|$가 노드의 개수의 제곱 $|V|^2$과의 차이가 작은 경우
[^1]: 하나의 간선으로 연결되어 있는