가볍게 말하면, *알고리즘*은 *입력*[^input]으로 어떤 값이나 값들의 집합을 받아서 *출력*[^output]으로 어떤 값이나 값들의 집합을 반환하는 '잘 정의된' 계산 절차입니다. 또는, 입력을 출력으로 변환하는 일련의 계산 절차입니다.

알고리즘은 입/출력 관계가 명확하게 정의된 계산 문제를 해결하는 도구로 볼 수 있습니다. 이 알고리즘은 문제에 주어진 입/출력 관계를 보여주기 위한 계산 절차를 묘사하게 됩니다.

예를 들어, 임의의 수열을 감소하지 않는 순서로 정렬하는 문제를 생각해 봅시다. 이 문제는 실제로도 많이 마주치는 문제이고, 여러 가지 설계 기술이나 분석 방법이 잘 알려져 있습니다. 여기서는 *정렬 문제*[^sorting_problem]를 형식적으로 정의해 봅시다:

- 입력 : $n$개의 숫자로 이루어진 수열 $<a_1, a_2, \dots, a_n>$.
- 출력 : 주어진 수열을 재정렬해서 $a'_1\le a'_2\le\cdots\le a'_n$ 조건을 만족하는 순열[^1] $<a'_1,a'_2,\dots,a'_n>$.

입력으로 수열 $<31,41,59,26,41,58>$이 주어지면, 정렬 알고리즘은 출력으로 수열 $<26,31,41,41,58,59>$를 반환합니다. 이런 입력 수열은 정렬 문제의 인스턴스라고 불립니다. 좀 더 일반적으로, 문제의 인스턴스는 문제의 해를 계산하기 위해 필요한 입력(문제 설명에서 제시된 모든 제약 조건을 만족시키는)으로 구성되어 있습니다.

많은 프로그램들이 정렬 알고리즘을 중간 과정에서 사용하기 때문에, 정렬은 컴퓨터 과학에서 기본적인 연산입니다. 그래서 여러 가지의 우수한 정렬 알고리즘이 잘 알려져 있습니다. 어떤 알고리즘이 특정 어플리케이션에 적합한지는, 정렬해야 할 항목의 수, 항목이 이미 어느 정도 정렬되어 있는지 정도, 항목 값에 대한 가능한 제한 사항, 컴퓨터의 아키텍처, 주 메모리, 디스크 또는 테이프 같은 저장 장치의 종류 같은 여러 요인에 따라 달라집니다.

알고리즘이 '옳다'는 것은, 모든 입력 인스턴스에 대해 옳은 출력과 함께 종료되는 것을 말합니다. 그리고 '옳은' 알고리즘이 주어진 계산 문제를 '풀었다'고 말합니다. '틀린' 알고리즘은 어떤 입력 인스턴스에 대해 종료되지 않거나, 틀린 답과 함께 종료될 수 있습니다. 기대했던 것과는 다르게, 만약 오류 비율을 통제할 수 있다면, 틀린 알고리즘도 유용할 수 있습니다. 나중에 큰 소수를 찾는 알고리즘에서 오류 비율을 통제하는 예제에 대해 알아볼 것입니다. 하지만, 보통은 '옳은' 알고리즘에 대해 고민합니다.

알고리즘은 사람의 언어로, 컴퓨터 프로그램으로, 또는 하드웨어 설계로도 명시할 수 있습니다. 다만, 따라야 할 계산 절차를 정확하게 설명해야만 합니다.
###### What kinds of problems are solved by algorithms?
알고리즘이 개발된 계산 문제는 정렬 문제 외에도 다양하게 있습니다. 알고리즘의 실용적인 응용은 매우 광범위하고, 다음과 같은 예제들이 포함됩니다.
- 인간 게놈 프로젝트는 인간 DNA의 10만 개 유전자를 모두 식별하고, DNA를 구성하는 30억 개의 염기 서열을 결정하고, 이 정보를 데이터베이스에 저장하고, 데이터를 분석하는 도구를 개발해 왔습니다. 이러한 각 단계는 정교한 알고리즘이 필요합니다. 알고리즘은 과학자들이 자원을 효율적으로 사용하면서 작업을 수행할 수 있도록 합니다.
- 인터넷은 전 세계 사람들이 대량의 정보를 신속하게 접근하고 검색할 수 있게 해줍니다. 알고리즘을 통해 인터넷 사이트들은 많은 데이터를 관리하고 조작할 수 있습니다. 알고리즘을 필수적으로 사용하는 문제의 예로, 데이터가 이동할 최적의 경로를 찾는 것과 특정 정보가 있는 페이지를 신속하게 찾기 위해 검색 엔진을 사용하는 것 등이 있습니다.
- 전자 상거래는 상품과 서비스를 전자적으로 협상하고 교환할 수 있게 해주며, 신용 카드 번호, 비밀번호, 은행 명세서 같은 개인 정보의 프라이버시에 의존합니다. 전자 상거래에 사용되는 핵심 기술은 공개 키 암호화와 디지털 서명을 포함하고 있고, 이것은 수치 알고리즘과 정수론에 기반을 두고 있습니다.
- 제조업 및 기타 상업적 기업들은 종종 제한되 자원을 가장 효율적으로 할당해야 합니다. 예를 들어, 석유 회사는 최대의 기대 수익을 얻기 위해 어디에 유정을 설치할지 고려해야 합니다. 정치 후보자는 선거에서 이길 가능성을 높이기 위해 캠페인 광고에 돈을 어떻게 쓸 지 고려해야 합니다. 항공사는 승무원 일정에 관한 정부 규정을 준수하면서 승무원을 최적의 방법으로 배정해야 합니다. 인터넷 서비스 제공자는 효과적인 서비스를 위해 추가 자원을 어디에 배치할지 고려해야 합니다. 이 모든 것들은 선형 계획법을 사용하여 해결할 수 있는 문제들입니다.

이 예제들의 몇 가지 세부 사항은 이 책에서 다룰 수 없겠지만, 위의 문제에 적용된 기본적인 기술이나 문제의 분야에 대해 알아볼 것입니다. 그리고 다음과 같은 것들을 포함하는 여러 문제의 해결 방법을 알아볼 것입니다:
- 각각의 인접한 지점 사이의 거리가 표시된 지도가 주어지고, 한 지점에서 다른 지점가지의 최단 경로를 찾고자 합니다. 경로끼리 교차하지 않도록 하더라도 가능한 경로의 수는 매우 많을 수 있습니다. 모든 가능한 경로 중에서 어떻게 최단 경로를 선택할 수 있을까요? 여기서 지도는 그래프로 모델링하며, 그래프에서 한 노드에서 다른 노드까지의 최단 경로를 찾고자 합니다.
- 두 개의 정렬된 기호 수열 $X=<x_1,x_2,\dots,x_m>$, $Y=<y_1,y_2,\dots,y_n>$에 대해 가장 긴 공통 부분 수열을 찾고자 합니다. 여기서 부분 수열은 주어진 수열에서 요소가 몇 개 제거된 것을 말합니다. 예를 들면, 기호 수열 $<A,B,C,D,E,F,G>$는 $<B,C,E,G>$를 부분 수열로 가집니다. $X$와 $Y$의 가장 긴 공통 부분 수열의 길이는 두 기호 수열이 얼마나 비슷한지 보여주는 수치입니다. 가령, 두 기호 수열이 DNA의 염기 서열 쌍이라면, 긴 공통 부분 수열을 가질 때 유사하다고 볼 수 있습니다. 만약 $X$가 $m$개, $Y$가 $n$개의 기호를 가지고 있다면 두 기호 수열이 가질 수 있는 부분 수열은 각각 $2^m$개, $2^n$개 입니다. 가능한 부분 수열을 모두 확인하는 것은 지나치게 긴 시간이 걸릴 것입니다. 이것을 효율적으로 해결하기 위해 *동적 프로그래밍*[^dynamic_programming]을 사용할 수 있습니다.
- 기계를 설계할 때, 각 부품은 다른 부품을 포함할 수 있고, 포함되는 부품이 먼저 사용되도록 순서를 정해야 합니다. 만약 부품이 $n$개 있다면, 가능한 모든 순서의 경우의 수는 $n!$입니다. 팩토리얼 함수는 지수 함수보다 빠르게 증가하기 때문에, 가능한 모든 순서를 고려하는 것은 현실적으로 불가능합니다. 이 문제는 *위상 정렬*[^topological_sort]을 이용해서 효율적으로 해결할 수 있습니다.
- 평면에 $n$개의 점이 주어졌을 때, 이 점들을 포함하는 볼록 껍질[^2]을 찾고자 합니다. 직관적으로는, 각 점을 판자에서 튀어나온 못으로 보고, 모든 못을 둘러싸는 고무 밴드로 생각할 수 있습니다. 고무 밴드가 방향을 바꾸며 감싸고 있는 못이 볼록 껍질의 꼭지점이 됩니다. 볼록 껍질의 꼭지점이 될 수 있는 점은 전체 점들의 집합의 부분 집합으로 표현될 수 있고, $n$개의 점이 주어졌으므로 가능한 부분 집합은 $2^n$개가 있습니다. 각각의 부분 집합이 볼록 껍질을 이루는지 확인하고, 어떤 순서로 나타나는지도 고려해야 합니다. 이러한 볼록 껍질을 찾는 두 가지 방법을 배우게 될 것입니다.

이것들 말고도 많은 알고리즘을 배우게 되겠지만, 위의 예제들은 여러 알고리즘 문제에서 공통적으로 나타나는 두 가지 특성을 보여줍니다:
1. 이 문제들은 여러 가지 방식으로 해결될 수 있지만, 대부분의 방식은 주어진 문제를 '효율적으로' 해결하지 못합니다. '효율적인' 또는 '최선의' 해결책을 찾는 것은 꽤 도전적인 일입니다.
2. 이 문제들은 실제 응용 사례를 갖고 있습니다. 최단 경로를 찾는 문제의 경우, 운송 회사가 도로 또는 철도 네트워크를 통해 최단 경로를 찾는 것으로 노동 비용이나 연료 비용을 절감할 수 있습니다. 또는 GPS 등을 이용해 운전 경로를 찾을 때 사용될 수도 있습니다.

알고리즘을 통해 얻어지는 해가 모두 쉽게 이해되고 적용할 수 있는 것은 아닙니다. 예를 들면, 신호의 샘플을 나타내는 수치의 집합이 주어졌을 때, 이 샘플의 이산 푸리에 변환[^discrete_Fourier_transform]을 계산하는 알고리즘은 시간 영역을 주파수 영역으로 변환하여 다양한 주파수의 강도를 샘플 신호에서 결정할 수 있도록 수치 계수를 계산합니다. 이산 푸리에 변환은 신호 처리의 핵심이며, 데이터 압축, 대형 다항식 및 정수 곱셈 등에서도 응용됩니다. 이것을 효율적으로 해결하기 위해 고속 푸리에 변환[^FFT] 알고리즘을 사용하고, 그것을 계산하기 위한 하드웨어 회로 설계도 간략하게 설명할 것입니다.
###### Data structures
이 책에서는 *자료 구조*[^data_structure]도 조금 다룹니다. 자료 구조는 데이터를 저장하고 조직화하여 접근 및 수정이 용이하도록 하는 방법입니다. 모든 목적에 잘 맞는 단일 자료 구조는 없기 때문에, 여러 자료 구조의 강점과 한계를 아는 것이 중요합니다.
###### Technique
이 책이 세상에 있는 모든 알고리즘을 담고 있는 것은 아닙니다. 이 책은 알고리즘을 설계하고 분석하는 기법을 가르쳐 주고, 스스로 개발한 알고리즘이 올바른 답을 제공하는지 보여주고, 그것의 효율성을 이해하도록 돕습니다. 각 장은 알고리즘 문제 해결의 다양한 측면을 다룹니다. 어떤 장에서는 구체적인 문제를 다루기도 합니다. 
###### Hard problems
이 책은 효율적인 알고리즘에 관한 책입니다. 여기서 효율의 기준은 속도입니다. 즉, 알고리즘에 결과를 반환할 때까지 시간이 얼마나 걸리는 지를 말합니다. 하지만 효율적인 해가 없는 문제도 있습니다. 34장에서 공부하게 될 문제들은 $NP$-complete로 알려져 있습니다.

$NP$-complete 문제가 흥미로운 이유는, 첫 번째로 $NP$-complete 문제에 대한 효율적인 알고리즘이 발견되지는 않았지만, 효율적인 알고리즘이 없다는 것도 증명되지 않았습니다. 다시 말하면, $NP$-complete 문제에 대해서는 효율적인 알고리즘이 있는지 없는지 모른다는 것입니다. 두 번째로, $NP$-complete 문제 집합은 다음과 같은 놀라운 속성을 가지고 있습니다: 만약 집합 원소 중 하나라도 효율적인 알고리즘이 존재한다면, 모든 $NP$-complete 문제에 대해 효율적인 알고리즘이 존재합니다. 셋째로, $NP$-complete 문제와 동일하지는 않지만 유사한 문제에 대해서는 효율적인 알고리즘이 알려져 있습니다. 컴퓨터 과학자들은 문제의 설명에 작은 차이가 최적 알고리즘의 효율에 큰 변화를 초래할 수 있다는 점을 흥미롭게 보고 있습니다.

$NP$-complete 문제에 대해서 알고 있어야 하는 이유는, 실제 응용 프로그램에서 종종 발생하는 문제이기 때문입니다. 만약 $NP$-complete 문제에 대한 효율적인 알고리즘을 만들어야 한다면, 많은 시간을 낭비할 가능성이 큽니다. 대신, 그 문제가 $NP$-complete 임을 증명할 수 있다면, 최적의 해결책은 아니더라도 다른 효율적인 알고리즘을 개발하는 데 시간을 쓸 수 있습니다.

구체적인 예로, 중앙 창고를 가진 배송 회사가 창고에서 트럭에 물건을 적재하고 여러 주소로 상품을 배달하려고 합니다. 배달이 끝나면 각 트럭은 다음 날을 위해 창고로 돌아와야 합니다. 비용을 줄이기 위해, 회사는 각 트럭이 이동하는 전체 거리를 최소화하는 배달 순서를 선택하려고 합니다. 이 문제는 잘 알려진 *외판원 문제*[^traveling-salesman_problem]로, $NP$-complete 문제입니다. 현재까지도 이 문제에 대한 효율적인 알고리즘은 알려져 있지 않습니다. 하지만 어떤 가정이 추가되면 최단 거리와 크게 차이나지 않는 전체 거리를 제공하는 효율적인 알고리즘이 존재합니다.
###### Parallelism




[^1]: 주어진 수열 $<a_1, a_2, \dots, a_n>$과 출력된 수열 $<a'_1, a'_2, \dots, a'_n>$은 각각의 요소가 일대일 대응되어야 한다.
[^2]: convex hull. 특정 점들을 포함하는 가장 작은 볼록 다각형.