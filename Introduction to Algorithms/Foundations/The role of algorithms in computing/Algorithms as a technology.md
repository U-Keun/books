만약 컴퓨터의 속도가 무한대이고, 메모리에도 제한이 없다고 하더라도, 당신의 프로그램이 옳은 답을 제공한다는 것을 증명하기 위해서는 알고리즘을 공부해야 합니다.

컴퓨터가 무한히 빠르다면, 문제를 해결하기 위한 옳은 답이라면 무엇이든 상관없을 것입니다. 또한, 프로그램을 잘 설계하고 문서화가 잘 되어 있도록 구현하겠지만, 대부분의 경우 구현하기 가장 쉬운 방법을 찾을 것입니다.

컴퓨터는 분명히 빨라지지만, 무한히 빨라지지는 않습니다. 메모리도 저렴해지겠지만, 제한이 없을 수는 없습니다. 그렇기 때문에 계산 시간은 제한된 리소스이고, 메모리 공간도 마찬가지입니다. 이 리소스를 현명하게 사용해야 하고, 알고리즘을 통해 시간 또는 공간 관점에서의 효율을 챙길 수 있습니다.
###### Efficiency
같은 문제를 해결하는 서로 다른 알고리즘은 종종 효율 관점에서 크게 차이가 날 수 있습니다. 이 차이는 하드웨어나 소프트웨어의 차이로 인한 효율보다 더 중요할 수 있습니다.

정렬 알고리즘을 예로 들어보겠습니다. *삽입 정렬*[^insertion_sort]은 $n$개의 항목을 정렬하는 데에 대략 $c_1 n^2$ 정도의 시간이 걸립니다. 즉, 실행 시간이 $n^2$에 비례합니다. *병합 정렬*[^merge_sort]의 경우, 대략 $c_2 n\log_2 n$ 정도의 시간이 걸립니다. 일반적으로는 $c_1 < c_2$이지만, 상수 요소보다 입력 크기인 $n$이 실행 시간에 더 큰 영향을 미칩니다. 
