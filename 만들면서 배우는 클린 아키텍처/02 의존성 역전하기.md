먼저 **단일 책임 원칙**[^Single Responsibility Principal, SRP]와 **의존성 역전 원칙**[^Dependency Inversion Principal, DIP]에 대해서 알아보자.
### 단일 책임 원칙
>컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

단일 책임 원칙은 보통 하나의 컴포넌트는 한 가지 일만 해야 한다는 것으로 알려져 있다. 여기서 '책임'은 '오로지 한 가지 일만 하는 것'보다는 '변경할 이유'로 해석하는 것이 좋다. 그리고 컴포넌트를 변경할 이유가 오로지 한 가지라면 컴포넌트는 딱 한 가지 일만 하게 된다.

컴포넌트를 변경할 이유가 여러 가지라면 고려해야 할 것이 많아지는 것이므로 변경 비용이 증가할 수 있다. 반대로 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트를 변경할 이유가 아니라면 이 컴포넌트에 대해서는 전혀 신경쓸 필요가 없다. 

추가로, '변경할 이유'는 컴포넌트 간의 의존성을 통해 쉽게 전파된다. 예를 들어, A라는 컴포넌트가 B라는 컴포넌트에 의존하고 있다면, A는 새로운 요구사항에 의해 변경이 일어날 수도 있고, B가 변경되어서 변경이 일어날 수도 있다. 
### 의존성 역전 원칙
>코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수)있다.

정확히는 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다. 서드파티 라이브러리 같은 것은 제어할 수 없기 때문이다. 의존성을 역전시키는 것으로 특정 컴포넌트의 '변경할 이유'의 개수를 줄일 수 있다. 다음의 예제를 보자.

<p align="center">
	<img width="400" src="../../../images/1.2.jpeg">
</p>

![[1.2.jpeg|center|400]]
**도메인 계층**에서 서비스 컴포넌트는 **영속성 계층**에 있는 엔티티 컴포넌트와 리포지토리 컴포넌트에 의존하고 있다. 즉, **도메인 계층** 코드는 **영속성 계층** 코드에 의존하고 있는데, 이 의존성을 역전시켜서 **영속성 계층** 코드가 **도메인 계층** 코드에 의존하도록 변경해보자.

<p align="center">
	<img width="400" src="../../../images/2.2.jpeg">
</p>

![[2.2.jpeg|center|400]]
**도메인 계층** 코드에 엔티티 컴포넌트와 리포지토리 인터페이스를 두고 실제 리포지토리 구현체를 **영속성 계층**에 두는 것으로, 더이상 **도메인 계층** 코드는 **영속성 계층** 코드에 의존하지 않는다. 다시 말하면, **영속성 계층**의 코드에서 변경이 일어나더라도 **도메인 계층**에서는 변경할 것이 없다.
### 클린 아키텍처
>클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트르르 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 어플리케이션이나 인터페이스로부터 독립적일 수 있다. - 로버트 C. 마틴 a.k.a Uncle Bob

이것은 **도메인 계층**의 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미하고, 이것은 클린 아키텍처에서 가장 주요한 규칙이다. 아래의 그림이 이것을 잘 표현한다.

<p align="center">
	<img width="300" src="../../../images/2.3.jpeg">
</p>

![[2.3.jpeg|center|300]]

여기서 유스케이스는 앞에서 서비스라고 불렸던 것인데, 하나의 기능이라고 생각하면 된다.

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다. 다만, 그렇기 때문에 어플리케이션의 엔티티에 대한 모델을 두 계층에서 각각 엔티티를 만들어서 두 엔티티를 서로 변환해서 사용해야 한다. 물론 다른 계층들 사이에서도 마찬가지다.
### 헥사고날 아키텍처
헥사고날 아키텍처는 알리스테어 콕번이 만든 용어로, 육각형은 아무 의미가 없다(?).

<p align="center">
	<img width="500" src="../../../images/2.4.jpeg">
</p>

![[2.4.jpeg|center|500]]
- 육각형(어플리케이션 코어) 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다.
- 육각형(어플리케이션 코어) 바깥에는 어플리케이션과 상호작용하는 다양한 어댑터들이 있다.
- 어플리케이션 코어와 어댑터들 간의 통신이 가능하려면 어플리케이션 코어가 각각의 포트를 제공해야 한다.
	- 왼쪽에 있는 어댑터들은 어플리케이션을 주도하는(driving) 어댑터인데, 포트가 코어에 있는 유스케이스 클래스들에 의해 구현되고 호출되는 인터페이스이다.
	- 오른쪽에 있는 어댑터들은 어플리케이션에 의해 주도되는(driven) 어댑터인데, 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스이다.

헥사고날 아키텍처도 계층으로 분류할 수 있는데, 가장 바깥쪽에 있는 계층은 어플리케이션과 다른 시스템 간의 번역을 담당하는 어댑터로 구성되어 있다. 다음으로는 포트와 유스케이스 구현체를 결합해서 어플리케이션 계층이다. 마지막 계층에는 도메인 엔티티가 위치한다.

<p align="center">
	<img width="300" src="../../../images/IMG_0787BFAB8361-1.jpeg">
</p>

![[IMG_0787BFAB8361-1.jpeg|center|300]]
### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
의존성을 역전시켜서 **도메인 계층** 코드가 다른 바깥쪽 계층의 코드에 의존하지 않게 함으로써 도메인 로직끼리의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다.

#CleanArchitecture 