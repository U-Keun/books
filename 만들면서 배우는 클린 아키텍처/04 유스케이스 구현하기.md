헥사고날 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티티를 만드는 것으로 시작한 후 해당 도메인 엔티티를 중심으로 유스케이스를 구현한다.
### 도메인 모델 구현하기
- 한 계좌에서 다른 계좌로 송금하는 유스케이스
	- `Account` 엔티티
		- 고유 ID(`id`), 현재 잔액(`baselineBalance`), 실제 계좌의 스냅샷(`ActivityWindow`)
			  실제 계좌의 스냅샷은 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동을 의미한다. 계좌에 대한 모든 입금과 출금은 `Activity` 엔티티가 갖고 있다.
			  `ActivityWindow` 클래스는 도메인 객체에 추가되어있다.
		- 입금과 출금은 `withdraw()` 메서드와 `deposit()` 메서드를 사용해서 새로운 활동을 활동창에 추가하는 것이다.
			  출금하기 전에는 잔고를 초과하는 금액은 출금할 수 없도록 하는 비즈니스 규칙을 검사한다.
### 유스케이스 둘러보기
일반적으로 유스케이스는 다음과 같은 단계를 따른다.
1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

``` 어플리케이션 계층
application
┣━ SendMoneyService
┗━ port
  ┣━ in
  ┃  ┣━ SendMoneyUseCase
  ┃  ┗━ SendMoneyCommand
  ┗━ out
	 ┣━ LoadAccountPort
	 ┗━ UpdateAccountStatePort
```

`SendMoneyService` 클래스는 `port.in` 패키지에 들어있는 `SendMoneyUseCase` 인터페이스를 구현한다. 비즈니스 로직을 처리한 뒤, `port.out` 패키지에 들어있는 `UpdateAccountStatePort` 인터페이스를 호출해서 데이터베이스의 계좌 상태를 업데이트할 것이다.
### 입력 유효성 검증
입력 유효성 검증은 유스케이스 클래스의 책임으로 두지 않는 것이 좋지만, 여전히 어플리케이션 계층의 책임이다. 어플리케이션 계층에서 입력 유효성 검증을 하지 않으면 어플리케이션 코어의 바깥에서 유효하지 않은 입력을 받았을 때 모델의 상태를 해칠 수 있다.

위의 어플리케이션 계층에서 유효성 검증은 **입력 모델**[^input model]인 `SendMoneyCommand` 클래스에서 실행한다. `SendMoneyCommand`는 유스케이스 API의 일부이기 때문에 `port.in` 패키지에 위치한다. 유효성 검증이 어플리케이션 코어에 남아있지만 유스케이스 코드를 오염시키지 않도록 구성할 수 있다.

유효성 검증을 돕는 표준 라이브러리로 Bean Validation API가 있는데, 공통으로 사용할 패키지에 추상 클래스(`SelfValidating` 클래스)를 만들어서 `SendMoneyCommand` 클래스가 그 추상 클래스를 상속받아서 사용할 수도 있다. 
### 생성자의 힘
빌더 패턴을 활용해서 매개변수가 많아지는 상황에 대처하는 것은 편리할 수 있지만, 컴파일러가 유효하지 않은 상태의 객체를 만들려는 시도에 대해 경고해주지 못하는 상황을 겪을 수 있다.

상황에 따라 적절하게 사용하는 것이 좋아보이는데, 나중에 빌더 패턴에 대해서 좀 더 알아봐야 할 것 같다.
### 유스케이스마다 다른 입력 모델
각기 다른 유스케이스에 동일한 입력 모델을 사용하고 싶을 때가 있다. 하지만 다른 유스케이스라면 다른 유효성 검사 로직이 필요할 수 있다. 이것은 비즈니스 코드를 입력 유효성 검증과 관련된 관심사로 오염시킬 수 있다.

각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다.
### 비즈니스 규칙 검증하기
비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야 할 때 시행해야 한다. 입력 유효성과는 다르게 비즈니스의 맥락이 필요하기 때문이다. 그러므로 비즈니스 규칙을 도메인 엔티티 안에 넣거나, 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 하는 것이 좋다.
### 풍부한 도메인 모델 vs. 빈약한 도메인 모델
풍부한 도메인 모델[^rich domain model]에서는 어플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다. 유스케이스는 사용자의 의도만을 표현하면서 이 의도를 실제 작업을 수행하는 체계화된 도메인 엔티티 메서드 호출로 변환한다. 그러므로 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.

빈약한 도메인 모델[^anemic domain model]에서는 엔티티 자체가 굉장히 얇다. 일반적으로 엔티티는 상태를 표현하는 필드와 이 값을 읽고 바꾸기 위한 `getter`, `setter` 메서드만 포함하고 어떤 도메인 로직도 가지고 있지 않다. 즉, 도메인 로직이 유스케이스 클래스에 구현되어 있다.

비즈니스의 필요에 맞게 두 가지 스타일을 사용하면 된다.
### 유스케이스마다 다른  출력 모델
입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋고, 출력 모델을 여러 유스케이스가 공유하지 않도록 하는 것이 좋다. 그리고 출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다. 추가적으로, 도메인 엔티티를 출력 모델로 사용하고 싶은 유혹도 견뎌야 한다.
### 읽기 전용 유스케이스는 어떨까?


 #CleanArchitecture 