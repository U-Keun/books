어플리케이션 컨텍스트와 오브젝트 팩토리는 어떤 차이점이 있는지 확인해보자. 먼저 `DaoFactory`의 `userDao()` 메서드를 두 번 호출해서 반환되는 `UserDao` 오브젝트를 비교해보자.
```java
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1); // UserDao@118f375
System.out.println(dao2); // UserDao@117a8bd
// 출력되는 값은 매번 달라진다.
```
두 오브젝트는 다른 값을 가진 동일하지 않은 오브젝트다. 

이번에는 어플리케이션 컨텍스트에 `DaoFactory`를 설정정보로 등록하고 `getBean()` 메서드를 이용해 `userDao`라는 이름으로 등록된 오브젝트를 두 개 가져와 보자.
```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);


System.out.println(dao3); // UserDao@ee22f7
System.out.println(dao4); // UserDao@ee22f7
```
두 오브젝트의 출력 값이 같으므로, `getBean()`을 두 번 호출해서 가져온 오브젝트가 동일하다는 것을 확인할 수 있다. 

**Spring**은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다. 
##### 1.6.1 싱글톤 레지스트리로서의 어플리케이션 컨텍스트
어플리케이션 컨텍스트는 IoC 컨테이너이면서 *싱글톤*을 저장하고 관리하는 *싱글톤 레지스트리*[^singleton registry]이다. **Spring**은 기본적으로 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.
###### 서버 어플리케이션과 싱글톤
**스프링**은 엔터프라이즈 시스템을 위해 고안된 기술이다. 대규모의 엔터프라이즈 서버환경은 서버에서 수많은 요청을 받아서 처리할 수 있는 성능이 요구되었고, 하나의 요청을 처리하기 위해 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조로 이뤄진 경우가 많았다. 그런데 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용하면, 서버가 감당하기 힘든 부하가 생길 것이다.

엔터프라이즈 분야에서는 서비스 오브젝트 개념으로 *서블릿*[^servlet]을 사용했다. 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 다시 말하면, 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.
> *싱글톤 패턴*[^Singleton Pattern]
> *싱글톤 패턴*은 어떤 클래스를 어플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 어플리케이션 내에서 전역적으로 접근이 가능하다. 단일 오브젝트만 존재해야 하고, 이를 어플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.
> 하지만, 사용하기가 까다롭고 여러 가지 문제점이 있어서, 피해야 할 패턴이라는 의미로, *안티 패턴*[^anti pattern]이라고 불리기도 한다.
###### 싱글톤 패턴의 한계
Java에서 싱글톤을 구현하는 방법은 보통 다음과 같다.
- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 `private`으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 정적 변수를 정의한다.
- 정적 팩토리 메서드인 `getInstance()`를 만들고 이 메서드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 정적 변수에 저장되거나 정적 변수의 초기값으로 오브젝트를 미리 만들어 둔다.
- 한 번 오브젝트(싱글톤)가 만들어지고 난 후에는 `getInstance()` 메서드를 통해 이미 만들어져 정적 변수에 저장해둔 오브젝트를 넘겨준다.

아래의 코드는 `UserDao`를 전형적인 싱글톤 패턴을 이용해 만든 것이다.
```java
public class UserDao {
	private static UserDao INSTANCE;
	...
	private UserDao(ConnectionMaker connectionMaker) {
		this.connectionMaker = connectionMaker;
	}

	public static synchronized UserDao getInstance() {
		if (INSTANCE == null) INSTANCE = new UserDao(???);
		return INSTANCE;
	}
}
```
생성자에 `private`이 붙어서 외부에서 호출할 수 없기 때문에 `DaoFactory`에서 `UserDao`를 생성하며 `ConnectionMaker` 오브젝트를 주입해주는 것이 불가능해졌다. 이외에도 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.
- `private` 생성자를 갖고 있기 때문에 상속할 수 없다.
  오직 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한하기 때문에 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.
- 싱글톤은 테스트하기가 힘들다.
  싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 *목* 오브젝트 등으로 대체하기가 힘들다. 테스트는 엔터프라이즈 개발의 핵심인데 어플리케이션 코드를 싱글톤으로 만들면 테스트를 만드는 데 지장이 있다는 것은 큰 단점이다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다. 여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.
- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
  싱글톤은 정적 메서드를 이용해 언제든지 쉽게 접근할 수 있기 때문에 어플리케이션 어디서든 사용될 수 있고, 그러다 보면 *전역 상태*[^global state]로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.
###### 싱글톤 레지스트리
**Spring**은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것을 지지하지만, Java의 기본적인 싱글톤 패턴의 구현 방식은 단점이 있기 때문에, 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 *싱글톤 레지스트리*[^singleton registry]다. Spring 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다. 평범한 Java 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.

**Spring**의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 어플리케이션 클래스라도 `public` 생성자를 가질 수 있다. 그러므로 테스트 환경에서도 자유롭게 오브젝트를 만들 수 있고, 테스트를 위한 목 오브젝트로 대체하는 것도 간단하다. 그리고 `DaoFactory`에서 `UserDao`에 `ConnectionMaker` 오브젝트를 사용하도록 관계를 설정해주듯이, 생성자 매개변수를 이용해서 사용할 오브젝트를 주입할 수도 있다.

가장 중요한 것은 싱글톤 패턴과 달리 **Spring**이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.
##### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있기 때문에 상태 관리에 주의를 기울여야 한다. 기본적으로는 상태정보를 내부에 갖고 있지 않은 *무상태*[^stateless] 방식으로 만들어져야 한다. 상태정보를 인스턴스 변수로 갖고 있다면, 저장할 공간이 하나뿐이니 하나의 스레드에서 값을 덮어쓰고, 다른 스레드에서는 그 스레드가 저장하지 않은 값을 읽어올 수도 있기 때문이다.

무상태 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 매개변수와 로컬 변수, 반환 값 등을 이용하여 다룰 수 있다. 메서드 매개변수나, 메서드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓰지 않을 것이다.

`UserDao`에서 `ConnectionMaker` 인터페이스 타입의 `connectionMaker`를 인스턴스 변수로 정의해서 사용했다. 이것은 읽기전용의 정보이기 때문에 인스턴스 변수로 사용해도 괜찮다. 덧붙이면, 이 변수에는 `ConnectionMaker` 타입의 싱글톤 빈이 들어있기 때문에 **Spring**이 한 번 초기화하고 나면 이후에는 수정되지 않기 때문이다.

물론 단순한 읽기전용 값이라면 `static final`이나 `final`로 선언하는 편이 낫다.
##### 1.6.3 스프링 빈의 스코프
빈이 생성되고, 존재하고, 적용되는 범위를 빈의 *스코프*[^scope]라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 한 컨테이너가 존재하는 동안 계속 유지된다. **Spring**에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.

싱글톤 외의 스코프로 *프로토타입*[^prototype] 스코프가 있다. 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다. 그 외에도 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성되는 *요청*[^request] 스코프가 있고, 웹의 세션과 스코프가 유사한 *세션*[^session] 스코프도 있다. 이외에도 다양한 스코프가 있는데, 나중에 다시 알아보겠다.

#TobySpring #Spring  