`UserService` 코드에서 트랜잭션 경계설정을 위해 넣은 코드를 분리해보자.
##### 6.1.1 메서드 분리
트랜잭션이 적용된 기존 코드를 보자.
```java
public void upgradeLevels() throws Exception {
	TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
	try {
		List<User> users = userDao.getAll();
		for (User user : users) {
			if (canUpgradeLevel(user)) {
				upgradeLevel(user);
			}
		}

		this.transactionManager.commit(status);
	} catch (Exception e) {
		this.transactionManager.rollback(status);
		throw e;
	}
}
```

위의 코드에서 `try` 문 내부의 코드만 비즈니스 로직이고, 그 이외의 코드는 모두 트랜잭션의 경계를 설정하는 부분이다. 이것은 비즈니스 로직을 구현한 부분을 메서드로 추출해서 역할을 독립시킬 수 있다. 이것을 적용한 코드를 보자.
```java
public void upgradeLevels() throws Exception {
	TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
	try {
		upgradeLevelsInternal();
		this.transactionManager.commit(status);
	} catch (Exception e) {
		this.transactionManager.rollback(status);
		throw e;
	}
}

private void upgradeLevelsInternal() {
	List<User> users = userDao.getAll();
	for (User user : users) {
		if (canUpgradeLevel(user)) {
			upgradeLevel(user);
		}
	}
}
```

##### 6.1.2 DI를 이용한 클래스의 분리
이번에는 트랜잭션 코드가 `UserService`에서 보이지 않도록 DI를 이용해서 분리해보자.
###### DI 적용을 이용한 트랜잭션 분리
만약 트랜잭션 코드를 `UserService`에서 분리하면 `UserService` 클래스를 직접 참조하여 사용하는 클라이언트 코드(현재는 `UserServiceTest`)에서는 트랜잭션 기능이 빠진 `UserService`를 사용하게 될 것이다. 이것은 구체적인 구현 클래스를 직접 참조하기 때문인데, DI를 이용해서 인터페이스를 통해 간접적으로 접근하게 만드는 것으로 해결할 수 있다.