##### 10.2.1 훼손의 정확한 감지
테스트 중인 코드가 어떤 식으로든 훼손되면 컴파일되지 않거나 테스트가 실패해야 한다. 이것은 다음의 두 가지 역할을 수행한다.
- 코드에 대한 초기 신뢰를 준다.
- 미래의 훼손을 막아준다.

> *회귀 테스트*[^regression test]
> 코드 변경(또는 다른 이벤트)으로 인해 잘 돌아가던 기능이 작동하지 않는 것을 *회귀*[^regression]라고 한다. 이러한 회귀를 탐지할 목적으로 테스트를 실행하는 것을 *회귀 테스트* 라고 한다.

추가로, '코드가 훼손되면 반드시 실패한다'는 것이 반드시 '코드가 훼손될 때만 테스트가 실패한다'는 것을 의미하는 것은 아니다. 예를 들어, 테스트 대상 코드(실제 코드)가 정상임에도 불구하고 때로는 통과하도 때로는 실패하는 테스트를 *플래키*[^flakey]라고 한다. 이것은 보통 무작위성, 타이밍 기반 레이스 조건, 외부 시스템에 의존하는 등의 동작때문에 발생한다. 플래키 테스트의 분명한 단점은 개발자들이 아무것도 아닌 것으로 판명 날 실패의 원인을 찾느라 시간을 낭비한다는 점이다. 
##### 10.2.2 세부 구현 사항에 독립적
일반적으로 개발자가 코드베이스에 가할 수 있는 변경은 두 가지 종류가 있고, 고려해야 하는 부분에도 약간의 차이가 있다.
- 기능적 변화
	'기능적 변화'는 코드를 사용하는 모든 사람에게 영향을 미치므로 이러한 변경을 가하기 전에 코드를 호출하는 쪽을 신중히 고려해야 한다. 기능적인 변경은 코드의 동작을 수정하기 때문에 테스트도 수정해야 할 것으로 기대하고 예상한다.
- 리팩터링[^refactoring]
	'리팩터링'은 코드를 사용하는 사람에게 영향을 미치지 않아야 한다. 구현 세부 사항을 변경하고 있지만 다른 사용자가 주의해야 할 행동은 없다.

단위 테스트를 처음 작성할 때, 코드의 모든 동작을 확인하고 다양한 세부 구현도 확인하는 것은 추후에 리팩터링을 진행했을 때, 테스트를 통과하기 위해 테스트 코드를 많이 변경해야 한다는 단점이 있다. 

가장 좋은 방법은 동작만 테스트하고 구현 세부사항은 확인하지 않는 것이다. 다시 말하면, 코드의 공개 API를 사용하여 상태를 설정하고 할 수 있는 곳에서 동작을 확인하는 것이다. 이 방법은 리팩터링을 진행하더라도, 리팩터링을 올바르게 수행했다면 테스트 코드를 수정할 필요 없이 테스트는 여전히 통과할 것이고, 테스트가 실패한다면 리팩터링이 잘못됐다는 것이 명백해진다.

간단하게 요약해보면, 기능적 변경에 의한 테스트 코드의 변경은 피하기 어렵지만, 세부 구현에 대한 테스트를 하지 않는 것으로 테스트 코드가 리팩터링에 대응하는 일이 없도록 하는 것이 생산적이다. 

##### 10.2.3 잘 설명되는 실패
개발자는 그들이 무심코 망가뜨린 코드를 잘 모를 수 있기 때문에 테스트 실패가 무엇이 잘못됐는지 알려주지 않는다면 그것을 알아내기 위해 많은 시간을 낭비해야 한다.

테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하는 것이다. 이렇게 하면 한 번에 모든 것을 테스트하려고 하는 하나의 큰 테스트 케이스보다 각각의 특정 동작을 확인하기 위한 작은 테스트 케이스가 많이 만들어지는데, 테스트가 실패할 때 실패한 케이스의 이름을 확인하는 것으로 어떤 동작이 작동하지 않는지 정확하게 알 수 있다.
##### 10.2.4 이해 가능한 테스트 코드
개발자가 자신이 변경한 사항이 원하는 동작에만 영향을 미친다는 확신을 가지려면 테스트의 어느 부분에 영향을 미치고 있는지, 테스트 코드에 대한 수정이 필요한지 여부를 알 수 있어야 한다. 그러므로 서로 다른 테스트 케이스가 무엇을 테스트하는지 그리고 어떻게 테스트하는지 이해하고 있어야 한다. 또한, 일부 개발자들은 테스트를 코드에 대한 일종의 사용 설명서로 사용하기 때문에 테스트 코드를 이해하기 쉽게 만들기 위해 노력해야 한다.
##### 10.2.5 쉽고 빠른 실행
대부분의 단위 테스트는 꽤 자주 실행된다. 단위 테스트를 실행할 때마다 몇 십 분이 걸린다면, 변경 사항을 병합하기 전이나 개발 도중에 수없이 실행하는 단위 테스트로 낭비하는 시간이 많아질 것이다. 나아가서, 개발자가 실제로 테스트를 할 수 있는 기회를 극대화하기 위해서도 테스트는 쉽고 빠르게 실행할 수 있도록 유지해야 한다.

#GoodCodeBadCode 