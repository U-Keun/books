궁극적으로 개발자는 코드를 사용하는 방법에 대한 정신 모델을 구축한다. 이 정신 모델은 코드 계약에서 발견한 것, 사전 지식, 적용할 수 있다고 생각하는 공통 패러다임에 근거해서 만들어진다. 코드가 실제로 하는 일이 이 정신 모델과 일치하지 않는다면, 코드 이해와 작성에 들어가는 시간이 낭비되거나 치명적인 버그가 발생할 수 있다.
#### 6.1 매직값을 반환하지 말아야 한다
**매직값**[^magic value]은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다. 일반적으로는 값이 없거나 오류가 발생했음을 나타내기 위해 `-1`을 반환하는 것이다.
##### 6.1.1 매직값은 버그를 유발할 수 있다
`-1`을 매직값으로 사용하는 경우만 생각해보아도, 그 반환값을 사용하는 메서드가 제대로 작동할 것이라고 확신할 수 없다. 코드를 작성한 개발자가 주석을 달아도, 주석을 제대로 확인하지 않으면 문제가 생길 수 있고, 어디서 버그가 발생하는지 찾기 힘들 수 있다.
##### 6.1.2 해결책 : 널, 옵셔널 또는 오류를 반환하라
메서드에서 매직값을 반환할 때의 문제점은 호출하는 쪽에서 계약의 세부 조항을 알아야 한다는 점이다. 

값이 없을 수 있는 경우 이것이 코드 계약의 명백한 부분에서 확인할 수 있도록 하는 것이 훨씬 좋다. 이를 위한 쉬운 방법 중 하나는 널 안전성을 지원하는 경우에는 널이 가능한 유형을 반환하고, 널 안전성을 지원하지 않는 경우에는 옵셔널 값을 반환하는 것이다.
널 값이나 비어 있는 옵셔널을 반환하는 것의 단점은 값이 없는 이유를 명시적으로 전달하지 않는다는 점이다.
##### 6.1.3 때때로 매직값이 우연히 발생할 수 있다
매직값 반환이 반드시 개발자의 의도에 의해서만 되는 것은 아니다. 개발자가 자신의 코드에 주어지는 모든 입력과 이러한 입력값들이 어떤 영향을 미칠 수 있을지에 대해 충분히 생각하지 않을 때도 매직값은 반환될 수 있다.
#### 6.2 널 객체 패턴을 적절히 사용하라
값을 얻을 수 없을 때 널 값이나 빈 옵셔널을 반환하는 대신 널 객체 패턴을 사용할 수 있다. 널 값을 반환하는 대신 유효한 값이 반환되어 그 이후에 실행되는 로직에서 널값으로 인해 시스템에 피해가 가지 않도록 할 수 있다.

널 객체 패턴은 4장에서 오류가 발생했다는 사실을 숨기기위해 사용하는 것이 때로는 바람직하지 않다는 것을 살펴봤다. 오류 처리 이외의 경우에 사용하면 유용하지만 이때도 역시 부적절하게 사용되면 예측을 벗어나는 동작을 하거나 발견하기 어려운 미묘한 버그가 발생할 수 있다.
##### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다
```
Set<String>? getClassNames(HtmlElement element) {
	String? attribute = element.getAttribute("class");
	if (attribute == null) {
		return null;
	}
	return new Set(attribute.split(" "));
}

Boolean isElementHighlighted(HtmlElement element) {
	Set<String>? classNames = getClassNames(element);
	if (classNames == null) {
		return false;
	}
	return classNames.contains("highlighted");
}
```
`getClassNames()` 함수는 널값을 통해 'class' 속성이 지정되어있는지 여부를 판별할 수 있지만, 그것을 판별하는 것은 별로 의미가 없다. 오히려 널을 반환하는 것 때문에 혼란스러운 경우가 많을 수 있다. 그리고 호출하는 쪽에서도 반환된 값이 널인지 여부를 확인해야 하는데, 이것 역시 코드를 지저분하게 만든다.
```
Set<String> getClassNames(HtmlElement element) {
	String? attribute = element.getAttribute("class");
	if (attribute == null) {
		return new Set();
	}
	return new Set(attribute.split(" "));
}

Boolean isElementHighlighted(HtmlElement element) {
	return getClassNames(element).contains("highlighted");
}
```
처음 코드에 널 객체 패턴을 사용했다. 호출하는 쪽의 코드가 간단해졌고, 코드가 예측을 벗어나는 작도을 할 가능성이 매우 낮다.
##### 6.2.2 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다
이전 하위 절에서는 널 대신 빈 컬렉션을 반환하는 예제를 보았는데, 이것을 문자열에도 적용할 수 있지만, 문제가 될 수 있는 경우도 있다.
###### 문자들의 모음으로서의 문자열
문자열이 단지 문자를 모아 놓은 것에 불과하고, 코드에서 그 외의 별다른 의미가 없다면 문자열이 없을 때 널 객체 패턴을 사용하는 것은 일반적으로 문제가 없다.
###### ID로서의 문자열
문자열이 항상 단순한 문자의 집합인 것만은 아니다. 예를 들어 문자열이 ID로 사용되는 예제를 보자.
```
class Payment {
	private final String? cardTransactionId;
	...
	String getCardTransactionId() {
		if (cardTransactionId == null) {
			return "";
		}
		return cardTransactionId;
	}
}
```
`cardTransactionId`가 널이면 빈 문자열을 반환하는 널 객체 패턴을 사용한다. 개발자들은 이 필드는 항상 널이 되지 않는 것으로 생각하고 따라서 카드 트랜잭션이 무조건 발생한 것이라고 생각할 수 있기 때문에 문제의 소지가 있다. 이런 경우에는 `cardTransactionId`가 널일 때 `getCardTransactionId()` 함수가 널을 반환하는 것이 훨씬 낫다.
```
class Payment {
	private final String? cardTransactionalId;
	...
	String? getCardTransactionId() {
		return cardTransactionId;
	}
}
```
##### 6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다
여기서 '더 복잡한 널 객체'라 함은 여러 가지 상태 데이터를 가질 수 있는 객체에 대해 무해하다고 가정하는 값을 할당해 두는 것을 말한다. 이것은 단순한 널 객체를 사용할 때와 장점과 단점을 공유한다. 다만 단순한 형태보다 예상을 벗어나는 결과를 나타낼 확률이 높다. 이런 경우에는 널을 반환하는 것이 더 나을 수 있다.
##### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다
널 객체 전용의 인터페이스나 클래스를 정의하기도 한다. 어떻게 보면 위에서 이야기한 더 복잡한 널 객체에 포함된다고 볼 수도 있는데, 조금 더 개선된 것은 널 객체를 가졌는지 명시적으로 확인할 수 있다는 점이다. 하지만 오히려 호출하는 쪽에서 널 전용 클래스의 인스턴스인지 확인하는 작업이 필요할 수 있고, 이것이 더 코드를 복잡하게 만들 수도 있다.
#### 6.3 예상치 못한 부수 효과를 피하라
**부수 효과**[^side effect]는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 말한다. 소프트웨어에서 부수 효과는 피할 수 없지만, 예상되지 않는 부수 효과는 최대한 피해야 한다.
##### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다
분명하고 의도적인 부수 효과는 호출하는 쪽에서 원하고 예상하는 바이다.
##### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다
메서드의 목적이 값을 가져오거나 읽기 위한 경우, 다른 개발자는 일반적으로 함수 호출이 부수 효과를 일으키지 않는다고 가정한다. 또는 서로 다른 스레드가 동일한 데이터에 액세스하는 경우에도 한 스레드로 인한 부수 효과는 다른 스레드에 문제를 일으킬 수 있다.
##### 해결책 : 부수 효과를 피하거나 그 사실을 분명하게 하라
애초에 부수 효과를 일으키지 않도록 코드를 작성하는 것이 가장 좋지만, 부수 효과가 어쩔 수 없이 일어난다면 부수 효과를 분명히 하기 위해 함수의 이름을 수정해서, 그 메서드를 호출하는 쪽에서 이 사실에 대해 명백하게 알 수 있도록 해야 한다.
#### 6.4 입력 매개변수를 수정하는 것에 주의하라
##### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다
입력으로 받은 객체는 이 메서드가 호출된 뒤에도 해당 객체를 다른 용도로 사용할 수도 있다. 일반적으로는 입력 매개변수의 수정이 일어나지 않을 것이라고 예상하기 때문에 함부로 입력 매개변수를 수정하는 것은 주의해야 한다.
##### 6.4.2 해결책 : 변경하기 전에 복사하라
입력 매개변수를 수정하고 싶다면 새 자료구조에 복사해서 원래의 객체가 변경되지 않도록 하는 것이 좋다. 그리고 성능상의 이유로 입력 매개변수를 변경해야 하는 경우 함수 이름과 문서에 이러한 일이 발생한다는 점을 분명히 하는 것이 좋다.
#### 6.5 오해를 일으키는 함수는 작성하지 말라
코드 계약에서 명백한 부분이 누락되는 것보다 오해의 소지가 있는 것이 더 좋지 않다.
##### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다
매개변수가 없더라도 호출할 수 있고 해당 매개변수가 없으면 아무 작업도 수행하지 않는 함수는 오해의 소지가 있을 수 있다. 호출하는 쪽에서 널을 확인해야 하는 것을 피하기 위해 사용할 수도 있지만, 호출하는 쪽에서는 해당 매개변수를 제공하지 않는 것이 초래할 결과를 예상하기 힘들고, 코드를 읽는 사람은 함수 호출 시 항상 무언가 작업이 이루어진다고 잘못 생각할 수 있다.
##### 6.5.2 해결책 : 중요한 입력은 필수 항목으로 만들라
어떤 매개변수 없이는 메서드가 수행하려는 작업을 못 하는 경우 그 매개변수는 해당 메서드에 중요한 변수이다. 이러한 매개변수는 널을 허용하지 않는 것이 더 안전할 수 있다.
>예상을 벗어나는 코드 때문에 발생한 버그를 수정하는 데 드는 시간과 노력은 널 여부를 확인하는 문장을 읽는 데 드는 시간보다 훨씬 더 크다.
#### 6.6 미래를 대비한 열거형 처리
우리가 의존하는 코드에 대해 부실한 가정을 할 경우에도 우리의 예상을 벗어나는 결과를 초래할 수 있다. 그 예로 열거형의 사용에 대해 이야기해보자. 어떤 이유든 열거형을 다뤄야 하는 상황이 있다. 그런 경우에, 열거형에 더 많은 값이 추가될 수 있다는 점을 기억하는 것이 중요하다.
##### 6.6.1 미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될 수 있다
열것값이 추가되는 상황을 고려해서 코드를 작성해야 한다.
##### 6.6.2 해결책 : 모든 경우를 처리하는 스위치 문을 사용하라
모든 열것값을 명시적으로 처리하고, 처리되지 않은 새로운 열것값이 추가되는 경우 컴파일이 실패하거나 테스트가 실패하도록 코드를 작성하는 것이다.
```
Boolean isGoodCase(CaseEnum case) {
	switch (case) {
		case A:
			return false;
		case B:
			return true;
	}
	throw new UncheckedException(
		"Unhandled case: " + case)
}
```
이 코드는 각각의 열것값을 사용하여 함수 호출을 수행하는 단위 테스트와도 결합할 수 있다.
```
testIsGoodCase_allCases() {
	for (EnumCase case in EnumCase.values()) {
		isGoodCase(case);
	}
}
```
단위 테스트와 함께 모든 값을 다 처리하는 스위치 문을 사용함으로써 코드가 예측을 벗어나 동작하거나 잠재적으로 치명적인 버그가 발생하지 않도록 방지할 수 있다.
##### 6.6.3 기본 케이스를 주의하라
스위치 문은 **기본**[^default] 케이스를 지원하는데, 이 방식을 사용하면 열거형 값이 암시적으로 처리될 수 있어서 주의해야 한다. 기본 케이스를 사용한다면, 열것값이 처리되지 않았음을 나타내는 예외를 기본 케이스에서 발생시키는 방법을 선택할 수 있다. 하지만 이 방법은 컴파일러가 모든 값이 처리되는 것으로 판단하기 때문에 컴파일러가 제공하는 추가적인 보호를 받을 수 없다. 웬만하면 컴파일러가 처리되지 않은 열것값에 대한 경고를 여전히 출력하도록 기본 케이스를 사용하지 않고 예외를 던지는 방식을 (이 책은) 추천한다.
##### 6.6.4 주의 사항 : 다른 프로젝트의 열거형에 의존
때로는 자신이 작성한 코드가 다른 프로젝트나 조직이 개발한 코드의 열거형에 의존할 수 있는데, 자신이 작성하지 않은 코드의 변경을 고려해서 적절하게 판단해야 한다.
#### 6.7 이 모든 것을 테스트로 해결할 수는 없는가?
테스트 코드만을 통해 예상을 벗어나는 코드를 피하는 것은 쉽지 않다. 충분한 시나리오나 코너 케이스를 테스트하지 않는 경우도 많고, 테스트 자체가 하기 어려운 경우도 있다.

#GoodCodeBadCode 