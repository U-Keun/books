B-Tree는 찾고자 하는 데이터를 빠르게 탐색할 수 있는 계층 구조를 구축합니다. 이것은 균형잡힌(balanced) 탐색 트리를 기반으로 구축되고 분기 개수(fanout)가 크고 높이가 낮습니다.

B-Tree의 노드는 아래의 그림처럼 표현됩니다. 이 형태는 자식 노드와 구분자 키(separator key)의 관계를 강조하기 위해 포인터 블럭도 명시적으로 표시된 모습입니다.
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 4.43.22.png">
</p>

![[스크린샷 2024-05-10 오후 5.01.04.png|center|350]]

B-Tree 노드 안에 있는 키들은 크기 순서대로 저장되어있기 때문에, 키를 찾을 때 이진 탐색 같은 알고리즘을 사용할 수 있습니다. 그리고 이것은 B-Tree의 검색 작업이 로그 시간 복잡도를 가진다는 것을 의미합니다. 예를 들어, 40억 개의 키 중 하나를 찾는다면 32번의 비교를 수행하면 됩니다. 각 비교에 대해 디스크 탐색을 수행해야 한다면 속도가 상당히 느려지겠지만 B-Tree 노드에는 수십 개 또는 수백 개의 항목이 저장되기 때문에 레벨 점프당 디스크 탐색을 한 번 수행하면 됩니다. 이것에 대해서는 뒤에서 좀 더 자세히 다루겠습니다.

B-Tree를 사용하면 점 쿼리와 범위 쿼리 모두 효율적으로 수행할 수 있습니다. 
##### B-Tree 계층 구조
B-Tree는 여러 개의 노드로 이루어져 있습니다. 그리고 각각의 노드는 최대 $N$ 개의 키와 $N + 1$ 개의 자식 노드를 가리키는 포인터를 가지고 있습니다. 노드는 다음 세 가지의 논리적 그룹으로 분류됩니다.
- 루트 노드 : 부모 노드가 없는 트리의 최상위 노드
- 리프 노드 : 자식 노드가 없는 최하위 노드
- 내부 노드 : 루트 노드와 리프 노드 사이에 있는 모든 노드
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 5.13.58.png">
</p>

![[스크린샷 2024-05-10 오후 5.13.58.png|center|400]]

B-Tree는 페이지 구성 기법(즉, 고정된 크기의 페이지를 구성하고 탐색하는 데 사용됨)이기 때문에 노드와 페이지라는 용어를 혼용하여 사용할 것입니다.

노드 용량과 노드가 실제로 보유하고 있는 키 수 사이의 관계는 *점유*[^occupancy]라고 부릅니다.

B-Tree는 각각의 노드에 저장돼있는 키의 개수(fanout)로 특징지어집니다. 키의 개수(fanout)가 많으면 트리의 균형을 유지하는 데 필요한 구조적 변경 비용을 분산시킬 수 있고, 키와 자식 노드를 가리키는 포인터를 하나의 블록 혹은 연속된 여러 블록에 저장함으로써 탐색 횟수가 줄어듭니다. 균형을 유지하는 작업(즉, *분할*[^split]과 *병합*[^merge])은 노드가 꽉 차거나 거의 비어 있을 때 실행됩니다.

> *B$^{+}$-Tree*
> 위의 특징을 가지는 데이터 구조를 B-Tree라는 용어로 사용하고 있지만, 정확한 이름은 B$^+$-Tree 입니다. 
> B-Tree는 루트 노드, 내부 노드, 리프 노드 어디든 값을 저장할 수 있지만, B$^+$-Tree는 리프 노드에만 값을 저장합니다. 내부 노드는 구분자 키(separator key)만 저장하는데, 리프 노드에 저장된 값을 탐색할 때 안내하는 역할을 합니다.
> B$^+$-Tree는 리프 레벨에만 값을 저장하기 때문에, 모든 작업(데이터 삽입, 업데이트, 제거, 조회)은 리프 노드에만 영향을 미치고 그 위의 노드에는 분할 및 병합 작업을 할 때만 전파됩니다.
> B$^+$-Tree가 널리 사용되고 있어서 여러 문서에서 이것을 B-Tree라고 부릅니다. 예로, MySQL InnoDB는 B$^+$-Tree의 구현을 B-Tree라고 부릅니다.

##### 구분자 키(Separator Key)
B-Tree 노드에 저장된 키는 *인덱스 항목*[^index entry], *구분자 키*[^separator key], 또는 *분할 셀*[^divider cell]이라고 불립니다. 이것은 트리를 서브트리(*브랜치*[^branch] 또는 *서브레인지*[^subrange])로 나누고, 대응되는 키의 범위를 가지고 있습니다. 키는 이진 탐색이 가능하도록 정렬되어 있습니다. 특정 키를 찾고 해당 포인터를 따라 상위 레벨에서 하위 레벨로 내려가면서 서브트리를 찾을 수 있습니다.

노드의 첫 번째 포인터는 첫 번째 키보다 작은 키를 가진 항목을 포함한 서브트리를 가리키고, 마지막 포인터는 마지막 키보다 크거나 같은 키를 가진 항목을 포함한 서브트리를 가리킵니다. 나머지 포인터들은 두 키 사이에 있는 키를 가진 항목을 포함한 서브트리를 가리킵니다: $K_S$가 $i - 1$ 번째 키인 $K_{i - 1}$보다 크거나 같고 $i$ 번째 키인 $K_i$ 보다 작은 경우 $K_S$를 포함한 서브트리를 $i$ 번째 포인터가 가리킵니다.($2 \leq i \leq N$)

<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 6.06.49.png">
</p>

![[스크린샷 2024-05-10 오후 6.06.49.png|center|400]]

B-트리의 일부 변형은 범위 검색을 단순화하기 위해 종종 리프 레벨에서 형제 노드 포인터를 가지고 있습니다. 이 포인터들은 다음 형제를 찾기 위해 부모 노드로 돌아가는 것을 피하게 도와줍니다. 일부 구현체에서는 양방향으로 포인터를 가지며, 이는 리프 레벨에서 이중 연결 리스트를 형성하여 역방향 반복을 가능하게 합니다.

B-Tree는 이진 탐색 트리와 달리 위에서 아래로 구축되는 것이 아니라, 아래에서 위로 구축됩니다. 리프 노드의 수가 증가함에 따라 내부 노드의 수도 늘어나고, 트리의 높이도 높아집니다.

B-Tree는 미래의 삽입이나 업데이트를 위해 노드 내부의 여유 공간을 남겨두기 때문에, 트리 저장소 활용률(또는 점유율)은 50%까지 낮아질 수 있지만, 보통은 상당히 높습니다. 점유율이 높을수록 B-Tree의 성능에 부정적인 영향을 미치지 않습니다.
###### B-Tree 탐색 복잡도
B-Tree의 탐색 복잡도는 탐색하는 동안 블럭이 전달된 횟수와, 비교 횟수의 두 가지 관점에서 볼 수 있습니다.

먼저 B-Tree에서 전체 데이터의 개수를 $M$, 각각의 노드가 가진 키의 개수를 $N$, 각 노드가 가리키고 있는 자식 노드의 최대 개수를 $K$, 트리의 높이를 $h$라고 하겠습니다. 

전달 횟수의 관점에서, 탐색하는 동안 최대 $\log_K M$ 또는 $h$개의 페이지(또는 노드)를 확인해야 합니다. 이것은 루트 노드에서 리프 노드를 향해 포인터를 따라가는 과정에서 거치는 노드의 개수입니다.

비교 횟수의 관점에서, 각각의 노드 안에서 이진 탐색을 수행하기 때문에 로그의 밑은 $2$입니다. 모든 비교는 각각의 검색 공간을 반으로 줄이기 때문에 복잡도는 $\log_2 M$입니다.

탐색 복잡도는 위에서 이야기한 전달 횟수와 비교 횟수를 통해 계산될 수 있습니다. 여러 책에서 B-Tree의 탐색 복잡도는 일반적으로 $\log M$으로 설명합니다. 로그의 밑은 상수로 계산되기 때문에 생략됩니다.
$$\log_a M = \frac{\log M}{\log a}$$
##### B-Tree 탐색 알고리즘
B-Tree의 구조와 내부 조직을 공부했으니, 데이터의 탐색, 삽입, 제거 알고리즘을 정의할 수 있습니다. B-Tree에서 데이터 항목을 찾기 위해서는 루트 노드에서 시작하여 리프 노드에 도달할 때까지의 경로를 따라가야 합니다. 이것의 목적은 원하는 키 또는 그것의 전임자[^1]를 찾는 것입니다. 정확히 대응되는 것을 찾는 것은 점 쿼리, 업데이트, 삭제에 사용되고, 전임자를 찾는 것은 범위 스캔과 삽입에 사용됩니다.

알고리즘은 루트 노드부터 이진 탐색을 수행합니다. 루트 노드에 저장된 키와 원하는 키를 비교해서 원하는 키의 상한(upper bound)이 되는 구분자 키를 찾습니다. 이것은 찾고자 하는 서브트리를 탐색하는 과정입니다. 서브트리를 찾으면 포인터를 따라 다음 노드로 이동하고 같은 탐색 과정을 그 노드에서 진행합니다. 이 과정은 목표로 하는 리프 노드에 도달할 때까지 반복됩니다. 결과적으로는, 원하는 키를 찾거나 전임자를 찾음으로서 존재하지 않는 키라고 결론짓게 됩니다.

트리는 아래로 내려갈수록 키에 대해 더 자세한 범위를 표현합니다. 그리고 리프 노드에는 데이터 레코드가 위치해 있습니다.

점 쿼리가 수행되는 동안, 탐색은 원하는 키가 찾아지거나 찾는 것을 실패한 후에 완료됩니다. 범위 스캔이 수행되는 동안에는 가장 가까운 키-값 쌍에서 반복이 시작되며, 범위의 끝에 도달하거나 범위 조건이 만족될 때까지 형제 포인터[^2]를 따라 계속됩니다.
##### Counting Keys
B-Tree에서 하나의 노드가 가지는 구분자 키와 포인터의 개수에 대해서, 어떤 책에서는 각각 $k$개, $2k + 1$개[^3] 또는 $N$개, $N + 1$개로 설명하는데, 두 가지 방식의 설명에 큰 차이는 없습니다. 이 책에서는 $N$개의 구분자 키를 가지는 것으로 생각하겠습니다.
##### B-Tree 노드 분할
B-Tree에 데이터를 삽입할 때, 목표로 하는 리프 노드를 찾고 삽입되는 지점을 결정해야 합니다. 리프 노드를 찾았다면 삽입되는 키와 값은 그 노드에 추가됩니다. B-Tree에서의 업데이트는 탐색 알고리즘으로 목표 리프 노드를 찾아서 존재하는 키에 대해 새로운 값을 연관지어줍니다.

목표 노드에 충분한 공간이 없으면 노드가 *오버플로우*[^overflow]되었다고 하며, 새로운 데이터를 저장하기 위해 해당 노드를 두 개로 나눠야 합니다. 다시 말하면, 다음과 같은 조건이 만족할 때 노드는 나뉘어집니다:
- 리프 노드의 경우 : 노드가 최대 $N$개의 키-값 쌍을 유지할 수 있고 하나의 키-값 쌍을 더 삽입하면 최대 용량 $N$을 초과하는 경우
- 리프 노드가 아닌 경우 : 노드가 최대 $N + 1$개의 포인터를 가질 수 있고, 하나의 포인터를 더 삽입하면 최대 용량 $N + 1$을 초과하는 경우

노드가 나뉠 때는, 새로운 노드를 할당해서 나눌 노드의 데이터의 절반을 새로운 노드로 전송하고, 그 노드의 첫 번째 키와 포인터를 부모 노드에 추가합니다. 이 경우, 키가 *승격된다*[^promoted]고 말하고, 노드의 분할이 수행되는 인덱스를 *분할점*[^split point](또는 *중간점*[^midpoint])이라고 합니다. (분할점을 포함한) 분할점 뒤의 요소들은 모두 새로 생성된 형제 노드로 전송되고, 나머지 요소들은 기존 노드에 남아있는 것입니다.

부모 노드에 승격된 키와 새로 생긴 노드로의 포인터가 저장될 공간이 없다면, 부모 노드 또한 나뉘어집니다. 이 작업은 루트 노드에도 동일하게, 재귀적으로, 수행됩니다.

트리의 모든 노드에 데이터가 가득 차면 루트 노드가 나뉘어야 합니다. 루트 노드가 분할이 되면, 분할점 키를 가지고 있을 새로운 루트가 할당됩니다. 기존의 루트 노드는 새로 생성된 형제 노드와 함께 더 이상 루트 노드가 아닌 새로운 루트 노드의 자식 노드가 되고, 트리의 높이가 하나 증가합니다. 트리의 높이는 이렇게 루트 노드가 나뉘어 새로운 루트 노드가 할당되거나 두 개의 노드가 하나의 루트 노드로 병합될 때 변합니다. 리프 노드 및 내부 노드 레벨에서 트리는 수평적으로 커집니다.

아래의 그림은 리프 노드에 데이터가 가득찬 상태에서 새로운 요소(`11`)이 추가되는 상황을 보여줍니다. 위에서 설명한 것처럼 리프 노드가 나뉘는 것을 확인할 수 있습니다.

<p align="center">
	<img width="450" src="../../../images/스크린샷 2024-05-12 오후 3.39.16.png">
</p>
![[스크린샷 2024-05-12 오후 3.39.16.png|center|450]]

아래의 그림은 리프 노드가 아닌 경우에 노드가 분할되는 상황을 보여주는데, 위의 경우와 크게 다른 점은 없습니다.

<p align="center">
	<img width="450" src="../../../images/스크린샷 2024-05-16 오후 1.36.00.png">
</p>
![[스크린샷 2024-05-16 오후 1.36.00.png|center|450]]

분할이 끝나면 삽입된 데이터가 노드에 추가되어야 합니다. 구분자 키가 승격된 키보다 작다면 기존 노드에 데이터가 추가되고, 그렇지 않으면 새로 생긴 노드에 데이터가 추가됩니다.
##### B-Tree 노드 병합
삭제는 목표 리프 노드를 찾으면 수행됩니다. 리프 노드가 탐색되면 키-값 쌍이 삭제됩니다.

이웃한 노드(또는 형제 노드)가 데이터를 너무 적게 가지고 있다면(즉, 점유율이 기준치 아래로 떨어지면) 형제 노드와 *병합*[^merge]됩니다. 이것을 *언더플로우*[^underflow]라고 부릅니다. 언더플로우 시나리오는 기본적으로 2가지가 있습니다: 공통인 부모 노드를 가지는 연속된 두 개의 노드가 
- 하나의 노드에 들어갈 만큼의 데이터를 가지고 있는 경우에는 두 노드의 데이터는 병합되어야 합니다.(concatenated)
- 하나의 노드에 들어갈 수 없을 만큼 데이터를 가지고 있는 경우에는 두 노드의 데이터는 *재분배*되어야 합니다.(rebalancing)

> 병합과 재분배는 서로 다른 기능이지만 언더플로우를 해결하는 방법으로 함께 제시됩니다. 

두 노드가 병합되는 상황을 좀 더 엄밀하게 구분하면 다음과 같습니다:
- 리프 노드의 경우, 이웃한 두 개의 노드가 가진 총 키-값 쌍이 $N$개 이하인 경우
- 리프 노드가 아닌 경우, 이웃한 두 개의 노드가 가진 총 포인터의 개수가 $N + 1$개 이하인 경우

아래의 그림은 리프 노드에서 특정 요소($16$)가 삭제되는 상황을 보여줍니다. B-Tree에서 노드가 분할되는 과정이 거꾸로 진행된다고 생각할 수 있습니다.
<p align="center">
	<img width="450" src="../../../images/스크린샷 2024-05-18 오전 8.13.51.png">
</p>
![[스크린샷 2024-05-18 오전 8.13.51.png|center|450]]

이 과정에서 데이터를 한 쪽으로 옮겨야 하는데, 일반적으로 오른쪽 형제 노드에서 왼쪽 형제 노드로 옮겨집니다. 이것은 키의 순서가 보존된다면 다른 방식으로 수행될 수 있습니다.

아래의 그림은 리프 노드가 아닌 경우에 노드가 병합되는 상황을 보여줍니다.
<p align="center">
	<img width="450" src="../../../images/스크린샷 2024-05-18 오전 8.36.09.png">
</p>
![[스크린샷 2024-05-18 오전 8.36.09.png|center|450]]

#DataBaseInternals  #DataBase 

[^1]: 주어진 키보다 작지만 가장 가까운 키를 의미합니다. 즉, 주어진 키 바로 이전의 키를 찾는 것입니다.
[^2]: 같은 부모 노드를 공유하는 노드들 간의 포인터를 의미합니다. 즉, 형제 포인터는 같은 레벨에 위치하면서 서로 인접한 노드들을 연결합니다. 이 포인터들은 주로 B-트리의 리프 노드들 간에 설정되어 있으며, 순차적 데이터 접근을 효율적으로 만드는 데 사용됩니다.
[^3]: 정확히는 $k$ ~ $2k$개의 구분자 키와 $k + 1$ ~ $2k + 1$ 개의 포인터입니다.