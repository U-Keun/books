데이터베이스 시스템의 원초적인 목적은 데이터를 저장하고 그것에 빠르게 접근하는 것입니다. 하지만 어떻게 데이터를 조직할까요? 왜 파일 뭉치가 아닌 DBMS가 필요할까요? 파일 조직화가 어떻게 효율을 개선할까요?

데이터베이스 시스템은 데이터를 저장하기 위해 파일을 사용하지만, 레코드를 찾기 위해 디렉토리와 파일의 파일 시스템 계층에 의존하는 대신 구현별 형식을 사용하여 파일을 구성합니다. 이렇게 파일을 구성해서 사용하는 이유는 다음과 같습니다:
- 저장소 효율 : 저장되는 데이터 레코드 당 저장소 오버헤드를 최소화하도록 구성합니다.
- 접근 효율 : 레코드는 가능한 한 짧은 단계로 찾을 수 있습니다.
- 수정 효율 : 레코드 수정은 디스크 상의 변경의 수를 최소화하는 방향으로 수행됩니다.

데이터베이스 시스템은 여러 필드로 구성된 *데이터 레코드*를 테이블에 저장하고, 각각의 테이블은 보통 별개의 파일로 표현됩니다. 테이블의 각 레코드는 검색 키를 사용해서 검색될 수 있습니다. 레코드를 찾기 위해 데이터베이스 시스템은 인덱스를 사용합니다: 모든 접근에 대해 전체 테이블을 검색하지 않고도 데이터 레코드를 효율적으로 찾을 수 있는 보조 데이터 구조입니다. 인덱스는 레코드를 식별하는 필드의 하위 집합을 사용하여 구축됩니다.

데이터베이스 시스템은 일반적으로 데이터 파일과 인덱스 파일을 분리합니다: 데이터 파일은 데이터 레코드를 저장하는 반면, 인덱스 파일은 레코드 메타데이터를 저장해서 데이터 파일에서 레코드를 찾기 위해 사용합니다. 인덱스 파일은 보통 데이터 파일보다 작습니다. 파일은 페이지로 나뉘는데, 이것은 단일 또는 여러 개의 디스크 블록 크기를 가집니다. 페이지는 레코드 시퀀스 또는 *slotted page*로 구성됩니다.

새로운 레코드를 추가하는 것과 기존의 레코드를 수정하는 것은 key/value 묶음으로 표현됩니다. 현대의 저장소 시스템 대부분은 명시적으로 페이지의 데이터를 삭제하지 않습니다. 대신 *deletion marker*(또는 *tombstones*)을 사용하여 키나 타임스탬프 같은 삭제 메타데이터를 포함하도록 합니다. 수정 또는 삭제 표시(marker)에 의해 음영 처리된 레코드가 차지하는 공간은 가비지 콜렉션이 수행되는 동안 회수됩니다. 다시 말하면, 가비지 컬렉션 수행 중에 페이지를 읽어서 음영 처리되지 않은 레코드를 새 위치에 쓰고, 음영 처리된 레코드는 삭제합니다.
##### Data Files
데이터 파일은 *index-organized table*[^IOT], *heap-organized table*[^heap files], *hash-organized table*[^hashed files]로 구현될 수 있습니다.

heap file에 있는 레코드는 특정한 순서가 없고 대부분 쓰기 명령에 의해 배치됩니다. 이렇게 하면 새 페이지가 추가될 때 추가적인 작업이나 파일의 재구성이 필요하지 않습니다. Heap file은 레코드를 검색할 수 있도록 데이터 레코드가 저장된 장소를 가리키는 인덱스 구조를 추가로 필요로 합니다.

hashed file에서, 레코드는 버켓에 저장되고, 각 키의 hash value는 레코드가 어느 버켓에 저장되는지를 결정합니다. 버켓의 레코드는 검색 속도를 개선하기 위해 추가되는 순서 또는 키로 정렬할 수 있습니다.

index-organized table은 데이터 레코드를 인덱스 자체에 저장합니다. 레코드가 키 순서대로 저장되기 때문에 IOT의 범위 스캔은 그 내용을 순차적으로 스캔하는 것으로 구현될 수 있습니다.

인덱스에 데이터 레코드를 저장하면 디스크 검색 횟수를 최소 1회 이상 줄일 수 있습니다. 왜냐하면, 인덱스를 이동하고 검색된 키를 찾은 후에, 관련 데이터 레코드를 찾기 위해 별도의 파일 주소를 지정할 필요가 없기 때문입니다.

레코드가 별도의 파일에 저장될 때, 인덱스 파일은 데이터 항목(*data entry*)을 보유하고 있고, 이것은 데이터 레코드를 고유하게 식별할 수 있게 하고, 데이터 파일에서 어떤 위치에 있는지에 대한 충분한 정보를 포함하고 있습니다. 예를 들면, *file offset*, 데이터 파일에서의 데이터 레코드의 위치, 또는 hash file의 경우 버켓 ID를 저장할 수 있습니다. index-organized table의 경우, 데이터 항목은 실제 데이터 레코드를 가지고 있습니다.
##### Index Files
인덱스는 효율적인 검색 작업을 용이하게 하는 방식으로 디스크의 데이터 레코드를 구성하는 구조입니다. 인덱스 파일은 키를 데이터 파일에서의 데이터 레코드의 위치와 대응시키는 특별한 구조로 구성되어 있습니다. 여기서, 그 키(heap file의 경우) 또는 기본 키(IOT의 경우)로 식별된 데이터 레코드가 저장됩니다.

데이터 파일 상의 인덱스는 *기본 인덱스*[^primary index]라고 불립니다. 하지만, 대부분의 경우 기본 인덱스는 기본 키 또는 기본으로 식별된 키 집합을 통해 구축된다고 가정할 수도 있습니다. 다른 모든 인덱스는 *보조 인덱스*[^secondary index]라고 불립니다.

보조 인덱스는 데이터 레코드를 직접 가리킬 수도 있고, 단순히 그것의 기본 키를 저장할 수도 있습니다. 데이터 레코드를 직접 가리키는 경우, 보조 인덱스는 heap file 또는 IOT에 대한 오프셋을 유지할 수 있습니다. 여러 개의 보조 인덱스는 같은 레코드를 가리킬 수 있어서, 하나의 데이터 레코드가 다른 필드로 식별될 수 있고, 서로 다른 인덱스를 통해 찾을 수 있습니다. 기본 인덱스 파일은 검색 키 당 유일한 항목을 가지고 있지만, 보조 인덱스는 검색 키 당 여러 개의 항목을 가지고 있을 수 있습니다.

데이터 레코드의 순서가 검색 키 순서를 따른다면, 이 인덱스는 *clustered*라고 부릅니다. clustered 데이터 레코드는 보통 같은 파일 또는 clustered 파일에 저장되고, 키 순서가 보존됩니다. 데이터가 분리되어 자장되어 있다면, 그것의 순서는 키 순서를 따르지 않을 것이고, 그러한 인덱스를 *nonclustered*라고 부릅니다.

아래의 그림은 다음의 두 가지 접근의 차이점을 보여줍니다:
- 두 개의 인덱스는 보조 인덱스 파일에서 직접 데이터 항목을 참조합니다.
- 보조 인덱스는 기본 인덱스의 간접 레이어를 통해 데이터 항목을 찾습니다.

<p align="center">
	<img width="500" src="../../../images/스크린샷 2024-04-28 오후 3.00.16.png">
</p>

![[스크린샷 2024-04-28 오후 3.00.16.png|center]]

많은 데이터베이스 시스템은 고유하고 명시적인 기본 키, 데이터베이스 레코드를 고유하게 식별하는 열 집합이 있습니다. 기본 키가 정해지지 않으면, 저장소 엔진은 암시적 기본 키를 생성할 수 있습니다.(예를 들면, MySQL InnoDB는 새로운 auto-increment 열을 추가하고 자동으로 값을 채웁니다.)

이 용어는 다른 종류의 데이터베이스 시스템에도 사용됩니다: 관계형 데이터베이스 시스템(MySQL이나 PostgreSQL 같은), Dynamo 기반 NoSQL 저장소(Apache Cassandra나 Riak 같은), 문서 저장소(MongoDB). 프로젝트마다 이름이 다를 수도 있지만, 이 용어에는 보통 명확한 명칭이 있습니다.
##### Primary Index as an Indirection
데이터베이스 커뮤니티에서는 데이터 레코드가 직접 참조되어야 하는지 아니면 기본 키 인덱스를 통해야 하는지에 대한 의견이 갈립니다.

두 접근 모두 장단점이 있습니다. 데이터를 직접 참조하면 디스크 검색 횟수를 줄일 수 있지만, 레코드를 수정하거나 유지보수 과정 중에 재배치 될 때마다 포인터를 업데이트 해줘야 합니다. 기본 인덱스를 이용한 간접 참조를 사용하면 포인터를 자주 업데이트하지 않아도 되지만, 경로를 읽어내는 비용이 더 큽니다.

간접 참조는 작업이 대부분 읽기로 구성된 경우 인덱스를 몇 개만 업데이트 하는 것으로 해결할 수 있지만, 여러 인덱스가 있고 쓰기 작업이 많은 경우에는 좋지 않습니다. 포인터 업데이트 비용을 줄이기 위해, 페이로드 오프셋 대신, 기본 키를 사용하는 구현도 있습니다. 예를 들면, MySQL InnoDB는 기본 인덱스를 사용하고 검색을 두 번 수행합니다: 한 번은 보조 인덱스로, 한 번은 기본 인덱스로 수행합니다. 이렇게 하면 보조 인덱스로 오프셋을 직접 따르는 대신 기본 인덱스 검색에 대한 오버헤드가 추가됩니다.

아래의 그림은 두 가지 다른 접근을 보여줍니다.
- 두 인덱스는 보조 인덱스 파일을 통해 데이터 항목을 직접 참조합니다.
- 보조 인덱스가 기본 인덱스의 간접 레이어를 통해 데이터 항목을 찾습니다.

<p align="center">
	<img width="700" src="../../../images/스크린샷 2024-05-01 오전 12.43.56.png">
</p>

![[스크린샷 2024-05-01 오전 12.43.56.png|center|700]]

데이터 파일 오프셋과 기본 키를 모두 저장하는 방법도 있습니다. 먼저 데이터 오프셋이 유효한지 확인하고 추가로 기본 키 인덱스가 변경되었는지 확인합니다. 새로운 오프셋을 찾은 후에는 인덱스 파일을 업데이트합니다.

#DataBase #DataBaseInternals 