이전 장에서는 스토리지 구조를 불변성 여부로 분류하고, *불변성*[^immutability]이라는 성질을 스토리지 구조의 설계와 구현에 영향을 미치는 핵심 개념으로 소개했습니다. 대부분의 변하는 성질[^mutable]을 가진 스토리지 구조는 *in-place update* 메커니즘을 사용합니다. 이것은 삽입, 삭제 또는 업데이트 가 수행될 때, 데이터 레코드는 해당 파일에서 데이터의 위치에서 직접 수정되는 것을 말합니다.

스토리지 엔진은 데이터베이스에 같은 데이터 레코드의 여러 버전을 가지고 있다;*Multiversion Concurrenct Control*이나 *Slotted Pages*가 그 예입니다. 개념적인 설명을 위해 일단은 각각의 키는 하나의 데이터 레코드에 대응되고, 유일한 장소에 저장되어있는 상황을 가정하겠습니다.

*B-Tree*는 많이 사용되는 스토리지 구조입니다. 많은 오픈소스 데이터베이스 시스템들은 B-Tree 기반이고, 수년에 걸쳐 여러 사용 예제에 사용될 수 있음이 증명되었습니다.

B-Tree는 Rudolph Bayer와 Edward M. McCreight에 의해 1971년에 발명되었습니다. 1979년에는 B-Tree의 여러 변형이 나왔습니다.

B-Tree에 대해 알아보기 전에, 이진 탐색 트리, 2-3-Tree 및 AVL Tree와 같은 기존 검색 트리의 대안을 고려해야 하는 이유를 알아보겠습니다.
##### 이진 탐색 트리
*이진 탐색 트리*[^binary search tree, BST]는 정렬된 인메모리 데이터 구조로 효율적인 키-값 검색을 위해 사용됩니다. BST는 여러 개의 노드로 구성되어 있고 각각의 노드는 키-값으로 표현됩니다. 그리고 '이진' 트리이므로 두 개의 자식 노드 포인터가 있습니다. BST는 루트 노드라고 불리는 하나의 노드로부터 시작됩니다.(임의의 트리는 하나의 루트만 가질 수 있습니다.)

각각의 노드는 탐색하는 공간을 왼쪽, 오른쪽 서브 트리로 분류합니다: 노드의 키는 왼쪽 서브트리에 저장된 모든 노드의 키보다 크고, 오른쪽 서브 트리에 저장된 모든 노드의 키보다 작습니다.
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-04 오전 12.52.15.png">
</p>
![[스크린샷 2024-05-04 오전 12.52.15.png|center|350]]

루트 노드부터 왼쪽 포인터를 따라 내려가면 가장 작은 키와 그것과 묶여있는 값을 가지고 있는 노드를 찾을 수 있습니다. 반대로 루트 노드부터 오른쪽 포인터를 따라 내려가면 가장 큰 키와 그것과 묶여있는 값을 가지고 있는 노드를 찾을 수 있습니다. 탐색은 루트 노드에서 시작하고, 리프 노드가 아닌 곳에서 탐색이 종료될 수 있습니다.(리프 노드보다 위 쪽에서 키가 탐색되는 경우)
##### Tree Balancing
기본적인 데이터의 삽입은 트리가 불균형한 상태(한 쪽 브랜치가 다른 한 쪽보다 긴 경우)로 만들 수도 있습니다. 최악의 시나리오는 *path* 형태의 트리입니다. *linked list* 데이터 구조와 비슷하게 생겼고, 탐색에 걸리는 시간 복잡도도 $O(\log N)$가 아닌 $O(N)$입니다.

위와 같은 경우가 자주 발생하는 것은 아니지만, *balanced tree*를 사용해야 하는 이유를 보여줍니다: 모든 항목이 아니더라도, 데이터가 한 쪽으로 치우쳐서 저장되면 탐색을 수행하는 시간이 길어집니다.

balanced tree는 다음과 같이 정의됩니다: $N$개의 노드를 가진 트리가, 높이가 $\log_2 N$이고 각각의 노드에 대해 두 서브 트리의 높이의 차이가 $1$보다 작아야 한다. balanced tree가 아니라면 이진 탐색 트리 구조의 '탐색'이라는 강점을 잃고, 데이터의 삽입 및 삭제 순서에 의해 트리의 형태를 결정될 것입니다.

balanced tree에서, 왼쪽 또는 오른쪽 노드를 따라 가는 것은 탐색할 공간을 평균적으로 절반 정도로 줄여주기 때문에 시간 복잡도가 $\log_2 N$이 됩니다. balanced tree가 아니라면, 최악의 경우에는 한 쪽 방향으로 모든 노드를 끝까지 탐색하기 때문에 시간복잡도는 $O(N)$입니다.

데이터 추가 시 한쪽 가지만 길어지게 하지 않고, 작업 후에도 트리가 균형을 유지하도록 조정합니다. 트리의 높이를 최소화하고 각 서브 트리의 노드 수를 적정 범위 내로 유지하도록 노드를 재배치하여 균형을 맞춥니다.

노드가 추가되거나 삭제된 후에도 balanced tree 형태를 유지하는 방법으로 *rotation*이 있습니다. 데이터가 삽입되는 과정에서, 예를 들어, 노드 `a`, `b`, `c`에 대해 `a` -> `b` -> `c` 형태로 연결되어 있고 `a`, `b` 노드가 각각 하나의 자식 노드만 갖게 되는 경우를 생각해보겠습니다. 이 경우 `b` 노드를 `a` 노드와 `c` 노드의 부모 노드로 바꾸는(*rotate*) 방식입니다.[^1]

<p align="center">
	<img width="400" src="../../../images/스크린샷 2024-05-06 오전 11.30.25.png">
</p>

![[스크린샷 2024-05-06 오전 11.30.25.png|center|400]]

##### 디스크 기반 스토리지에서의 트리
위에서 말했듯, 노드의 탐색을 수행하는 데 unbalanced tree는 최악의 경우 $O(N)$의 시간복잡도를 가지고, balanced tree는 $O(\log_2 N)$의 시간복잡도를 가집니다. 동시에, unbalanced tree는 *fanout*[^2]도 작기 때문에 노드를 재배치하고 포인터를 업데이트해서 균형적인 상태를 유지해야 합니다. 하지만 이것은 BST의 유지 관리 비용을 높여서 디스크 기반 데이터 구조로는 비효율적입니다.

BST를 디스크에서 관리하게 되면 생기는 문제도 몇 가지 있는데, 그 중 하나는 지역성(locality)입니다: 노드가 임의의 순서로 추가되기 때문에, 새로 생성되는 노드가 그것의 부모 노드와 가까이 저장된다는 것이 보장되지 않습니다. 이것은 자식 노드로의 포인터가 여러 디스크 페이지에 걸쳐 있을 수 있음을 의미합니다. 이런 상황은 트리의 레이아웃을 개조하고 *Paged Binary Tree*를 사용해서 대응할 수 있습니다.

또 다른 문제는 트리의 높이인데, 이것은 자식 노드를 가리키는 포인터


#DataBase  #DataBaseInternals 

[^1]: 여기서 `b` 노드는 *rotation pivot*이라고 불립니다.
[^2]: 노드 당 허용되는 최대 자식 노드 개수