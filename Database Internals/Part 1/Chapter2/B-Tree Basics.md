이전 장에서는 스토리지 구조를 불변성 여부로 분류하고, *불변성*[^immutability]이라는 성질을 스토리지 구조의 설계와 구현에 영향을 미치는 핵심 개념으로 소개했습니다. 대부분의 변하는 성질[^mutable]을 가진 스토리지 구조는 *in-place update* 메커니즘을 사용합니다. 이것은 삽입, 삭제 또는 업데이트 가 수행될 때, 데이터 레코드는 해당 파일에서 데이터의 위치에서 직접 수정되는 것을 말합니다.

스토리지 엔진은 데이터베이스에 같은 데이터 레코드의 여러 버전을 가지고 있다;*Multiversion Concurrenct Control*이나 *Slotted Pages*가 그 예입니다. 개념적인 설명을 위해 일단은 각각의 키는 하나의 데이터 레코드에 대응되고, 유일한 장소에 저장되어있는 상황을 가정하겠습니다.

*B-Tree*는 많이 사용되는 스토리지 구조입니다. 많은 오픈소스 데이터베이스 시스템들은 B-Tree 기반이고, 수년에 걸쳐 여러 사용 예제에 사용될 수 있음이 증명되었습니다.

B-Tree는 Rudolph Bayer와 Edward M. McCreight에 의해 1971년에 발명되었습니다. 1979년에는 B-Tree의 여러 변형이 나왔습니다.

B-Tree에 대해 알아보기 전에, 이진 탐색 트리, 2-3-Tree 및 AVL Tree와 같은 기존 검색 트리의 대안을 고려해야 하는 이유를 알아보겠습니다.
##### 이진 탐색 트리
*이진 탐색 트리*[^binary search tree, BST]는 정렬된 인메모리 데이터 구조로 효율적인 키-값 검색을 위해 사용됩니다. BST는 여러 개의 노드로 구성되어 있고 각각의 노드는 키-값으로 표현됩니다. 그리고 '이진' 트리이므로 두 개의 자식 노드 포인터가 있습니다. BST는 루트 노드라고 불리는 하나의 노드로부터 시작됩니다.(임의의 트리는 하나의 루트만 가질 수 있습니다.)

각각의 노드는 탐색하는 공간을 왼쪽, 오른쪽 서브 트리로 분류합니다: 노드의 키는 왼쪽 서브트리에 저장된 모든 노드의 키보다 크고, 오른쪽 서브 트리에 저장된 모든 노드의 키보다 작습니다.
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-04 오전 12.52.15.png">
</p>
![[스크린샷 2024-05-04 오전 12.52.15.png|center|350]]

루트 노드부터 왼쪽 포인터를 따라 내려가면 가장 작은 키와 그것과 묶여있는 값을 가지고 있는 노드를 찾을 수 있습니다. 반대로 루트 노드부터 오른쪽 포인터를 따라 내려가면 가장 큰 키와 그것과 묶여있는 값을 가지고 있는 노드를 찾을 수 있습니다. 탐색은 루트 노드에서 시작하고, 리프 노드가 아닌 곳에서 탐색이 종료될 수 있습니다.(리프 노드보다 위 쪽에서 키가 탐색되는 경우)
##### Tree Balancing
기본적인 데이터의 삽입은 트리가 불균형한 상태(한 쪽 브랜치가 다른 한 쪽보다 긴 경우)로 만들 수도 있습니다. 최악의 시나리오는 *path* 형태의 트리입니다. *linked list* 데이터 구조와 비슷하게 생겼고, 탐색에 걸리는 시간 복잡도도 $O(\log N)$가 아닌 $O(N)$입니다.

위와 같은 경우가 자주 발생하는 것은 아니지만, *balanced tree*를 사용해야 하는 이유를 보여줍니다: 모든 항목이 아니더라도, 데이터가 한 쪽으로 치우쳐서 저장되면 탐색을 수행하는 시간이 길어집니다.

balanced tree는 다음과 같이 정의됩니다: $N$개의 노드를 가진 트리가, 높이가 $\log_2 N$이고 각각의 노드에 대해 두 서브 트리의 높이의 차이가 $1$보다 작아야 한다. balanced tree가 아니라면 이진 탐색 트리 구조의 '탐색'이라는 강점을 잃고, 데이터의 삽입 및 삭제 순서에 의해 트리의 형태를 결정될 것입니다.

balanced tree에서, 왼쪽 또는 오른쪽 노드를 따라 가는 것은 탐색할 공간을 평균적으로 절반 정도로 줄여주기 때문에 시간 복잡도가 $\log_2 N$이 됩니다. balanced tree가 아니라면, 최악의 경우에는 한 쪽 방향으로 모든 노드를 끝까지 탐색하기 때문에 시간복잡도는 $O(N)$입니다.

데이터 추가 시 한쪽 가지만 길어지게 하지 않고, 작업 후에도 트리가 균형을 유지하도록 조정합니다. 트리의 높이를 최소화하고 각 서브 트리의 노드 수를 적정 범위 내로 유지하도록 노드를 재배치하여 균형을 맞춥니다.

노드가 추가되거나 삭제된 후에도 balanced tree 형태를 유지하는 방법으로 *rotation*이 있습니다. 데이터가 삽입되는 과정에서, 예를 들어, 노드 `a`, `b`, `c`에 대해 `a` -> `b` -> `c` 형태로 연결되어 있고 `a`, `b` 노드가 각각 하나의 자식 노드만 갖게 되는 경우를 생각해보겠습니다. 이 경우 `b` 노드를 `a` 노드와 `c` 노드의 부모 노드로 바꾸는(*rotate*) 방식입니다.[^1]

<p align="center">
	<img width="400" src="../../../images/스크린샷 2024-05-06 오전 11.30.25.png">
</p>

![[스크린샷 2024-05-06 오전 11.30.25.png|center|400]]

##### 디스크 기반 스토리지에서의 트리
위에서 말했듯, 노드의 탐색을 수행하는 데 unbalanced tree는 최악의 경우 $O(N)$의 시간복잡도를 가지고, balanced tree는 $O(\log_2 N)$의 시간복잡도를 가집니다. 동시에, unbalanced tree는 *fanout*[^2]도 작기 때문에 노드를 재배치하고 포인터를 업데이트해서 균형적인 상태를 유지해야 합니다. 하지만 이것은 BST의 유지 관리 비용을 높여서 디스크 기반 데이터 구조로는 비효율적입니다.

BST를 디스크에서 관리하게 되면 생기는 문제도 몇 가지 있는데, 그 중 하나는 지역성(locality)입니다: 노드가 임의의 순서로 추가되기 때문에, 새로 생성되는 노드가 그것의 부모 노드와 가까이 저장된다는 것이 보장되지 않습니다. 이것은 자식 노드로의 포인터가 여러 디스크 페이지에 걸쳐 있을 수 있음을 의미합니다. 이런 상황은 트리의 레이아웃을 개조하고 *Paged Binary Tree*를 사용해서 대응할 수 있습니다.

또 다른 문제는 트리의 높이인데, 이것은 자식 노드를 가리키는 포인터의 비용과 관련이 있습니다. 이진 트리는 fanout이 2이기 때문에, 트리의 높이는 $\log_2 N$입니다. 그러므로 원하는 내용을 찾기 위해 $O(\log_2 N)$ 만큼의 탐색이 필요하고, 그만큼의 디스크 전송을 수행해야 합니다. *2-3-Tree* 같이 작은 fanout을 가지는 트리에도 비슷한 한계가 있습니다: 그러한 트리는 인메모리 데이터 구조에는 유용한 반면, 외부 스토리지로 사용되면 효율적이지 않습니다.

디스크 상에 단순한 BST 구현은 지역성에 대해 내장된 개념이 없기 때문에 비교 횟수 만큼 디스크 탐색이 필요합니다. 그러므로 지역성을 고려할 수 있는 데이터 구조를 사용해야 합니다.

디스크 상에 트리를 구현하는 좋은 방법은 다음과 같은 요소를 고려해야 합니다:[^3]
- 이웃한 키들의 지역성을 높이기 위한 큰 fanout
- 탐색 횟수를 줄이기 위한 낮은 높이
##### 디스크 기반 구조
[[Memory- Versus Disk-Based DBMS|이전에]] 메모리 기반 스토리지와 디스크 기반 스토리지에 대해 이야기했습니다. 특정한 데이터 구조에 대해서도, 디스크에서 사용되기 좋은 데이터 구조와 메모리에서 사용되기 좋은 데이터 구조로 구별할 수 있습니다.

모든 데이터 구조가 디스크 스토리지에서 사용되기에 적합한 공간과 복잡도를 가지지는 않습니다. 데이터베이스에서 사용되는 데이터 구조는 영구 저장 매체의 제한을 고려해서 조정되어야 합니다.

디스크에서 데이터 구조는 데이터의 크기가 너무 커서 전체 데이터셋을 메모리에 둘 수 없을 때 주로 사용됩니다. 데이터의 일부만 메모리에 *캐싱*될 수 있고, 나머지는 디스크에 저장되어 효율적으로 접근하도록 합니다.
###### Hard Disk Drives
대부분의 전통적인 알고리즘은 회전 디스크가 가장 널리 사용되는 영구 저장 매체일 때 개발되었으며, 이는 설계에 큰 영향을 미쳤습니다. 이후에 플래시 드라이브와 같은 저장 매체의 새로운 발전은 새로운 알고리즘과 기존 알고리즘의 개조, 새로운 하드웨어의 성능을 개선하는 데 영향을 끼쳤습니다. 요즘에는 비휘발성의 바이트로 주소를 지정하는 저장소에서 작동하도록 최적화된 새로운 유형의 데이터 구조가 등장하고 있습니다.

회전하는 디스크에서는 읽기/쓰기 헤드를 원하는 위치에 배치하기 위해 디스크 회전 및 기계적 헤드 이동이 필요하기 때문에 랜덤 읽기 비용이 증가합니다. 하지만, 비용이 비싼 작업이 한 번 수행되고 나면, 연속적인 바이트의 읽기와 쓰기 작업은 상대적으로 비용이 저렴합니다.

회전 드라이브의 가장 작은 전달 단위는 *sector*로, 어떤 작업이 수행될 때 적어도 하나의 전체 sector가 읽히거나 쓰여집니다. sector의 크기는 일반적으로 512 바이트에서 4 Kb입니다.

헤드 배치는 HDD의 작업 수행에서 가장 비싼 작업입니다. 이것이 순차적인 I/O[^4]가 효과적인 이유이기도 합니다.
###### Solid State Drives
SSD는 회전하는 디스크가 없고 헤드를 배치할 필요가 없습니다. 일반적인 SSD는 *메모리 셀*로 만들어져있고, *스트링*으로 연결되어 있고(스트링 당 32 ~ 64개의 셀), 스트링은 *어레이*로 합쳐지고, 어레이는 *페이지*로 합쳐지고, 페이지는 *블럭*으로 합쳐집니다.

사용되는 기술에 따라, 셀은 하나 또는 여러 비트의 데이터를 가지고 있습니다. 페이지는 기기의 크기에 따라 다양하지만, 일반적으로는 2 ~ 16 Kb입니다. 블럭은 보통 64 ~ 512개의 페이지를 포함합니다. 블럭은 *플레인* 상에 배치되고, 마지막으로, 플레인은 *다이*에 배치됩니다. SSD는 하나 이상의 다이를 가집니다.

쓰기나 읽기 작업이 수행되는 가장 작은 단위는 페이지입니다. 하지만 비어 있는 메모리 셀(즉, 쓰기 전에 지워진 메모리 셀)만 변경할 수 있습니다. 가장 작은 소거 엔티티[^5]는 페이지가 아니라 여러 페이지를 보유하는 블럭이므로 흔히 소거 블록이라고 합니다. 소거 블럭에서 페이지는 순차적으로 쓰기 작업이 수행되어야 합니다.

플래시 메모리 컨트롤러에서 페이지 ID를 물리적 위치에 매핑하고 빈 페이지, 쓴 페이지 및 버려진 페이지를 추적하는 역할을 담당하는 부분을 *FTL*[^Flash Translation Layer]이라고 합니다. 이것은 *가비지 컬렉션* 역할도 하는데, 가비지 컬렉션이 수행되는 동안 FTL은 안전하게 지울 수 있는 블럭을 찾습니다. 이 때 블럭에 몇 개의 페이지가 남아있을 수도 있습니다. 이 경우에는 그 페이지를 새로운 위치로 재배치하고, 페이지 ID를 다시 매핑하여 새로운 위치를 가리키도록 합니다. 그러고 나서 사용되지 않는 블럭을 지우고 쓰기 작업이 수행될 수 있도록 합니다.

HDD와 SSD 모두 개별 바이트가 아닌 메모리 청크를 다루기 때문에(즉, 데이터 블록 단위로 액세스), 대부분의 운영체제는 *블럭 장치 추상화*[^6]가 있습니다. 이것은 내부적인 디스크 구조를 숨기고 내부적으로 I/O 작업을 버퍼링하므로, 저장 매체에서 하나의 단어를 읽을 때 해당 단어가 포함된 전체 블록을 읽습니다. 이것은 디스크에 있는 데이터 구조를 이용해서 작업할 때 무시할 수 없는 제약조건이고 항상 고려해야 합니다.

SSD에서는, 랜덤 및 순차적 I/O에 대해 HDD에서 만큼 강조하지 않았습니다. 왜냐하면 지연 시간의 차이가 그렇게 크지 않기 때문입니다. 다만 프리페칭, 연속된 페이지 읽기, 내부 병렬로 인한 지연시간의 차이는 있습니다.

가비지 컬렉션은 백그라운드에서 수행되는 작업이지만, 랜덤 및 정렬되지 않은 쓰기 작업의 성능에 부정적인 영향을 미칠 수 있습니다.

블럭의 전체 크기 만큼만 쓰기 작업을 수행하거나 같은 블럭에 순차적인 쓰기 작업을 수행하는 것은 필요한 I/O 작업의 횟수를 줄일 수 있습니다. 이것을 위한 버퍼링과 불변성에 관한 이야기를 책의 뒷부분에서 이야기할 예정입니다.
###### On-Disk Structures
디스크 액세스 비용 외에도 효율적인 디스크 상의 구조를 구축하기 위해서는 디스크 작업의 최소 단위가 블럭이라는 사실에 주목해야 합니다. 블럭 내의 특정 위치를 포인터를 따라가기 위해서는 전체 블럭을 가져와야 합니다. 이것을 활용할 수 있도록 데이터 구조를 바꿀 수 있습니다.

이번 장에서 '포인터'를 몇 번 언급했지만, 이것은 디스크 상의 구조에서 약간 다른 의미를 가집니다. 디스크에서는 대부분의 경우 데이터 레이아웃을 수동으로 관리합니다(*memory mapped files*를 사용하지 않는 한). 이것도 흔히 말하는 '포인터'와 유사한 역할을 수행하지만, 목표 포인터 주소를 계산하고 포인터를 명시적으로 따라야 합니다.

대부분의 경우, 디스크 상의 오프셋은 미리 계산되어 있거나 디스크에 플러시 될 때까지 메모리에 캐싱되어 있습니다. 디스크 상의 구조에서 데이터 요소들 간의 의존성을 나타내는 '포인터'의 사용이 많아질수록 코드와 구조가 복잡해지기 때문에, 포인터의 수와 그 범위를 최소화하는 것이 바람직합니다.

요약하자면, 디스크 기반 구조는 저장 장치의 특성을 고려하여 설계되며, 주로 디스크 접근 횟수를 줄이기 위해 최적화됩니다. 이러한 최적화는 데이터의 지역성을 향상시키고, 데이터 구조의 내부 표현을 개선하며, 페이지 외부 포인터의 수를 줄이는 방법 등으로 실행됩니다.

디스크에서 사용하는 트리 구조는 큰 분기(fanout)와 낮은 높이를 가지는 것이 이상적입니다. 그동안은 포인터로 인한 공간적 오버헤드와 포인터를 재배치하는 데 필요한 오버헤드에 대해 논의해왔습니다. B-트리는 이러한 고려사항을 통합하여, 노드의 분기를 높임으로써 트리의 높이를 줄이고, 노드 내 포인터의 수를 최소화하며, 포인터 재배치 횟수를 감소시킵니다.

> *Paged Binary Tree*
> 아래의 그림처럼 노드를 그룹화해서 페이지로 저장하는 것으로 지역성을 개선할 수 있습니다. 다음 노드를 찾으려면 가져온 페이지 내에서 포인터를 따라가면 됩니다. 하지만, 여전히 노드와 포인터에 의한 오버헤드는 존재합니다. 이 데이터 구조를 디스크에서 관리하는 것도 쉽지 않습니다. 키와 값이 미리 정렬되어 있지 않고 임의의 순서로 추가되는 경우에 특히 더 그렇습니다. 페이지에 대한 재배치도 필요하고, 이것은 포인터의 재배치 또한 요구합니다.

<p align="center">
	<img width="400" src="../../../images/스크린샷 2024-05-10 오후 4.43.22.png">
</p>

![[스크린샷 2024-05-10 오후 4.43.22.png|center|400]]

##### Ubiquitous B-Trees
B-Tree는 찾고자 하는 데이터를 빠르게 탐색할 수 있는 계층 구조를 구축합니다. 이것은 균형잡힌(balanced) 탐색 트리를 기반으로 구축되고 분기 개수(fanout)가 크고 높이가 낮습니다.

B-Tree의 노드는 아래의 그림처럼 표현됩니다. 이 형태는 자식 노드와 구분자 키(separator key)의 관계를 강조하기 위해 포인터 블럭도 명시적으로 표시된 모습입니다.
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 4.43.22.png">
</p>

![[스크린샷 2024-05-10 오후 5.01.04.png|center|350]]

B-Tree 노드 안에 있는 키들은 크기 순서대로 저장되어있기 때문에, 키를 찾을 때 이진 탐색 같은 알고리즘을 사용할 수 있습니다. 그리고 이것은 B-Tree의 검색 작업이 로그 시간 복잡도를 가진다는 것을 의미합니다. 예를 들어, 40억 개의 키 중 하나를 찾는다면 32번의 비교를 수행하면 됩니다. 각 비교에 대해 디스크 탐색을 수행해야 한다면 속도가 상당히 느려지겠지만 B-Tree 노드에는 수십 개 또는 수백 개의 항목이 저장되기 때문에 레벨 점프당 디스크 탐색을 한 번 수행하면 됩니다. 이것에 대해서는 뒤에서 좀 더 자세히 다루겠습니다.

B-Tree를 사용하면 점 쿼리와 범위 쿼리 모두 효율적으로 수행할 수 있습니다. 
###### B-Tree 계층 구조
B-Tree는 여러 개의 노드로 이루어져 있습니다. 그리고 각각의 노드는 최대 $N$ 개의 키와 $N + 1$ 개의 자식 노드를 가리키는 포인터를 가지고 있습니다. 노드는 다음 세 가지의 논리적 그룹으로 분류됩니다.
- 루트 노드 : 부모 노드가 없는 트리의 최상위 노드
- 리프 노드 : 자식 노드가 없는 최하위 노드
- 내부 노드 : 루트 노드와 리프 노드 사이에 있는 모든 노드
<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 5.13.58.png">
</p>

![[스크린샷 2024-05-10 오후 5.13.58.png|center|400]]

B-Tree는 페이지 구성 기법(즉, 고정된 크기의 페이지를 구성하고 탐색하는 데 사용됨)이기 때문에 노드와 페이지라는 용어를 혼용하여 사용할 것입니다.

노드 용량과 노드가 실제로 보유하고 있는 키 수 사이의 관계는 *점유*[^occupancy]라고 부릅니다.

B-Tree는 각각의 노드에 저장돼있는 키의 개수(fanout)로 특징지어집니다. 키의 개수(fanout)가 많으면 트리의 균형을 유지하는 데 필요한 구조적 변경 비용을 분산시킬 수 있고, 키와 자식 노드를 가리키는 포인터를 하나의 블록 혹은 연속된 여러 블록에 저장함으로써 탐색 횟수가 줄어듭니다. 균형을 유지하는 작업(즉, *분할*[^split]과 *병합*[^merge])은 노드가 꽉 차거나 거의 비어 있을 때 실행됩니다.

> *B$^{+}$-Tree*
> 위의 특징을 가지는 데이터 구조를 B-Tree라는 용어로 사용하고 있지만, 정확한 이름은 B$^+$-Tree 입니다. 
> B-Tree는 루트 노드, 내부 노드, 리프 노드 어디든 값을 저장할 수 있지만, B$^+$-Tree는 리프 노드에만 값을 저장합니다. 내부 노드는 구분자 키(separator key)만 저장하는데, 리프 노드에 저장된 값을 탐색할 때 안내하는 역할을 합니다.
> B$^+$-Tree는 리프 레벨에만 값을 저장하기 때문에, 모든 작업(데이터 삽입, 업데이트, 제거, 조회)은 리프 노드에만 영향을 미치고 그 위의 노드에는 분할 및 병합 작업을 할 때만 전파됩니다.
> B$^+$-Tree가 널리 사용되고 있어서 여러 문서에서 이것을 B-Tree라고 부릅니다. 예로, MySQL InnoDB는 B$^+$-Tree의 구현을 B-Tree라고 부릅니다.

###### 구분자 키(Separator Key)
B-Tree 노드에 저장된 키는 *인덱스 항목*[^index entry], *구분자 키*[^separator key], 또는 *분할 셀*[^divider cell]이라고 불립니다. 이것은 트리를 서브트리(*브랜치*[^branch] 또는 *서브레인지*[^subrange])로 나누고, 대응되는 키의 범위를 가지고 있습니다. 키는 이진 탐색이 가능하도록 정렬되어 있습니다. 특정 키를 찾고 해당 포인터를 따라 상위 레벨에서 하위 레벨로 내려가면서 서브트리를 찾을 수 있습니다.

노드의 첫 번째 포인터는 첫 번째 키보다 작은 키를 가진 항목을 포함한 서브트리를 가리키고, 마지막 포인터는 마지막 키보다 크거나 같은 키를 가진 항목을 포함한 서브트리를 가리킵니다. 나머지 포인터들은 두 키 사이에 있는 키를 가진 항목을 포함한 서브트리를 가리킵니다: $K_S$가 $i - 1$ 번째 키인 $K_{i - 1}$보다 크거나 같고 $i$ 번째 키인 $K_i$ 보다 작은 경우 $K_S$를 포함한 서브트리를 $i$ 번째 포인터가 가리킵니다.($2 \leq i \leq N$)

<p align="center">
	<img width="350" src="../../../images/스크린샷 2024-05-10 오후 6.06.49.png">
</p>

![[스크린샷 2024-05-10 오후 6.06.49.png|center|400]]



#DataBase  #DataBaseInternals 

[^1]: 여기서 `b` 노드는 *rotation pivot*이라고 불립니다.
[^2]: 노드 당 허용되는 최대 자식 노드 개수
[^3]: fanout과 트리의 높이는 반비례합니다. 
[^4]: 디스크에서 연속적인 메모리 세그먼트를 읽거나 쓰는 것을 말합니다.
[^5]: 플래시 메모리나 다른 유형의 비휘발성 메모리에서 데이터를 삭제할 수 있는 최소 단위를 의미합니다.
[^6]: 이 추상화는 저장 장치에서 데이터를 고정된 크기의 블록 단위로 접근하는 특성을 기반으로 하며, 이를 통해 운영 시스템은 다양한 타입의 물리적 장치를 같은 방식으로 취급할 수 있게 됩니다.