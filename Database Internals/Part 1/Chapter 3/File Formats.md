B-Tree의 기본적인 개념에 대해서 알아보았으니, B-Tree와 다른 데이터 구조가 디스크에서 어떻게 구현되는지 알아보겠습니다. 메인 메모리에 접근하는 방식과 디스크에 접근하는 방식은 다릅니다. 어플리케이션 개발자의 관점에서, 메모리에 접근하는 것은 보통 투명하게 이루어집니다. 가상 메모리 덕분에 메모리 접근은 수동으로 오프셋을 관리할 필요가 없습니다. 반면 디스크 접근은 시스템의 호출로 수행되고, 목표 파일 안에 오프셋을 지정해야 합니다. 그리고 메인 메모리에 적합한 형식으로 디스크 상에서의 표현을 해석해야 합니다.

그 차이점을 고려해서 디스크 상의 데이터 구조를 설계해야 합니다. 그것을 위해서는 파일 포맷이 구축하기 쉽고, 수정하기 쉽고, 해석하기 쉬워야 합니다. 이번 장에서는 파일 포맷에 대한 일반적인 원칙과 B-Tree뿐만 아니라 다른 디스크 상의 데이터 구조를 설계하는 데 도움이 되는 예제를 알아볼 것입니다.

B-Tree의 구현은 다양한 방식으로 가능하고, 이 책에서는 그 중 몇 가지의 유용한 기술에 대해 이야기합니다. 세부적인 사항은 구현마다 다양하지만, 일반적인 원칙은 같습니다. 노드의 분할이나 병합같은 B-Tree의 기초적인 메커니즘을 이해하고 있더라도 실제 구현을 위해서는 추가적으로 알아야 할 것들이 많이 있습니다.

디스크 상의 데이터 구조에서 포인터 관리의 의미는 메모리 상에서와 다소 차이가 있습니다. 디스크 상의 B-Tree는 페이지 관리 메커니즘으로 생각하는 것이 좋습니다. 알고리즘이 페이지를 구성하고 찾아가는 방식이기 때문입니다. 페이지와 포인터는 그 알고리즘에 따라 계산되고 배치되어야 합니다.

B-Tree를 구현할 때 어려운 점은 가변성에서 비롯되므로, 페이지 레이아웃, 분할, 재배치, 그리고 다른 가변 데이터 구조에 적용 가능한 개념들에 대한 세부 사항을 알아볼 것입니다. 이후에 *LSM Tree*에 대해서는 정렬과 유지 관리에 관한 내용에 집중할 것입니다. 
#### [[Motivation]]
#### [[Binary Encoding]]
#### [[General Principles]]
#### [[Page Structure]]
#### [[Slotted Pages]]
#### [[Cell Layout]]
#### [[Combining Cells into Slotted Pages]]
#### [[Managing Variable-Size Data]]
#### [[Versioning]]
#### [[Checksumming]]


#DataBaseInternals #DataBase 