리눅스에서 구동되는 프로세스는 *유저 프로세스*와 *커널 프로세스*로 분류할 수 있다. 각 프로세스의 종류에 따라 프로세스의 생성 과정이 다르다.
- 유저 프로세스 : 유저 공간에서 프로세스를 생성하는 라이브러리(GNU C : glibc)를 통해 커널에게 프로세스 생성을 요청한다.
- 커널 프로세스 : 커널 내부의 `kthread_create()` 함수를 호출해서 커널 프로세스를 생성한다.
프로세스를 실제로 생성할 때는 `kernel_clone()` 함수를 호출한다. 다시 말하면, 위의 두 과정에서 공통적으로 `kernel_clone()` 함수를 호출하여 새로운 프로세스를 생성한다.

리눅스에서는 `init`과 `kthreadd` 프로세스가 프로세스 생성을 전담하고 있다. `init` 프로세스는 유저 레벨 프로세스를 생성하고, `kthreadd` 프로세스는 커널 레벨 프로세스를 생성한다.[^1]

###### `kernel_clone()` 함수 선언부와 반환값
`kernel_clone()` 함수는 소스 코드에서 `/linux/kernel/fork.c`에 선언되어 있다.
```C
pid_t kernel_clone(struct kernel_clone_args *args) {
	u64 clone_flags = args->flags;
	struct completion vfork;
	struct pid *pid;
	struct task_struct *p;
	int trace = 0;
	pid_t nr;

	...

	return nr;
}
```
매개변수로 들어간 `kernel_clone_args` 구조체에는 프로세스를 생성할 때 지정하는 옵션(`flags`)이나, 유저 영역에서 스레드를 생성할 때 복사하려는 스택의 주소(`stack`), 유저 영역에서 실행 중인 스택의 크기(`stack_size`), 부모와 자식 스레드 그룹을 관리하는 핸들러 정보(`parent_tid`, `child_tid`) 등의 정보를 포함하고 있다.


[^1]: 프로세스는 생성보다 복제된다고 말하는 것이 정확하다. 이것은 프로세스를 생성할 때 프로세스에게 필요한 리소스를 각각 할당 받는 것보다, 이미 생성된 프로세스에게서 리소스를 물려받는 것이 더 효율적이기 때문이다.