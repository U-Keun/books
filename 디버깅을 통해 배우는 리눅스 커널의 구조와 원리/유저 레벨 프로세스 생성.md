유저 공간에서 `fork()` 함수를 호출하면 *glibc*를 통해 커널에게 프로세스 생성을 요청한다. 라이브러리 코드가 실행되면, 리눅스 커널 공간에서는 `fork()` 함수에 대응하는 시스템 콜 핸들러인 `sys_clone()` 함수를 호출한다.
```C
#ifdef __ARCH_WANT_SYS_CLONE
#ifdef CONFIG_CLONE_BACKWARDS
SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp, 
				int __user *, parent_tidptr, 
				unsigned long, tls, 
				int __user *, child_tidptr)
...
#endif
{
	struct kernel_clone_args args = {
		.flags = (lower_32_bits(clone_flags) & ~CSIGNAL),
		.pidfd = parent_tidptr,
		.child_tid = child_tidptr,
		.parent_tid = parent_tidptr,
		.exit_signal = (lower_32_bits(clone_flags) & CSIGNAL),
		.stack = newsp,
		.tls = tls,
	};

	return kernel_clone(&args);
}
```
그리고 위의 코드에서 확인할 수 있듯이, `kernel_clone()` 함수를 호출하여 프로세스를 생성한다.

유저 레벨 프로세스를 생성하는 흐름을 다시 정리해보면 다음과 같다.
- 유저 공간에서 `fork()` 함수를 호출하면 시스템 콜을 발생시킨다.
- 커널 공간에서 `sys_clone()` 함수를 호출한다.
- `sys_clone()` 함수는 `kernel_clone()` 함수를 호출해 프로세스를 생성한다.

###### 실행 실습 및 `ftrace` 로그 분석
