유저 공간에서 `fork()` 함수를 호출하면 *glibc*를 통해 커널에게 프로세스 생성을 요청한다. 라이브러리 코드가 실행되면, 리눅스 커널 공간에서는 `fork()` 함수에 대응하는 시스템 콜 핸들러인 `sys_clone()` 함수를 호출한다.
```C
#ifdef __ARCH_WANT_SYS_CLONE
#ifdef CONFIG_CLONE_BACKWARDS
SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp, 
				int __user *, parent_tidptr, 
				unsigned long, tls, 
				int __user *, child_tidptr)
...
#endif
{
	struct kernel_clone_args args = {
		.flags = (lower_32_bits(clone_flags) & ~CSIGNAL),
		.pidfd = parent_tidptr,
		.child_tid = child_tidptr,
		.parent_tid = parent_tidptr,
		.exit_signal = (lower_32_bits(clone_flags) & CSIGNAL),
		.stack = newsp,
		.tls = tls,
	};

	return kernel_clone(&args);
}
```
그리고 위의 코드에서 확인할 수 있듯이, `kernel_clone()` 함수를 호출하여 프로세스를 생성한다.

유저 레벨 프로세스를 생성하는 흐름을 다시 정리해보면 다음과 같다.
- 유저 공간에서 `fork()` 함수를 호출하면 시스템 콜을 발생시킨다.
- 커널 공간에서 `sys_clone()` 함수를 호출한다.
- `sys_clone()` 함수는 `kernel_clone()` 함수를 호출해 프로세스를 생성한다.

##### 실행 실습 및 `ftrace` 로그 분석
다음과 같은 간단한 프로그램을 이용하여 프로세스가 생성되고, 종료되는 과정을 확인해보자.
```C
#include <stdio.h>
#include <unistd.h>

#define PROC_TIMES 500
#define SLEEP_DURATION 3

int main() {
        int proc_times = 0;

        for (proc_times = 0; proc_times < PROC_TIMES; proc_times++) {
                printf("raspbian tracing \n");
                sleep(SLEEP_DURATION);
        }

        return 0;
}
```
해당 코드를 컴파일하여 `raspbian_proc` 이라는 실행 파일을 만들어 두었다.
###### 프로세스 생성 단계
![[스크린샷 2025-01-03 오후 6.53.51.png|center|700]]

`bash-2819` 프로세스가 위와 같은 콜 스택으로 실행 중인 것을 나타낸다. 유저 공간에서 `clone` 시스템 콜이 걸려오면, 아키텍처(ARM64)에 맞는 시스템 콜 핸들러(`__arm64_sys_clone`)로 진입하고, 내부적으로 공통 처리를 위한 `__do_sys_clone` 함수를 호출한 후, `kernel_clone()` → `copy_process()`로 이어진다.

`el0` 키워드를 포함하고 있는 함수들은 ARM64에서 유저 모드 → 커널 모드로 진입할 때 거치는 예외 처리 루틴이다.
	
그 아래에는 자식 프로세스가 `bash-2981`로 생성되었음을 보여준다.

###### `raspbian_proc` 프로세스 실행 단계
아래와 같은 로그가 3초 간격으로 나타나는 것을 확인할 수 있었다.(31752.~ 다음으로 31755.~, 31758.~가 나오는 식이다.)
![[스크린샷 2025-01-03 오후 7.08.20.png|center|700]]

###### 프로세스 종료 단계
