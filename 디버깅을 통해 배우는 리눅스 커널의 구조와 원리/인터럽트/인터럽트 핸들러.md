어떤 인터럽트에 대해, 지정된 인터럽트 핸들러가 호출되려면 해당 인터럽트 핸들러가 등록되어 있어야 한다. 인터럽트 핸들러는 인터럽트를 초기화하는 과정에서 호출하는 `request_irq()` 함수를 통해 등록된다.
##### `request_irq()` 함수
`request_irq()` 함수는 다음과 같이 선언되어 있다.
```C
// https://github.com/raspberrypi/linux/tree/rpi-6.6.y/include/linux/interrupt.h
...
/**
 * request_irq - Add a handler for an interrupt line
 * @irq:	The interrupt line to allocate
 * @handler:	Function to be called when the IRQ occurs.
 *		Primary handler for threaded interrupts
 *		If NULL, the default primary handler is installed
 * @flags:	Handling flags
 * @name:	Name of the device generating this interrupt
 * @dev:	A cookie passed to the handler function
 *
 * This call allocates an interrupt and establishes a handler; see
 * the documentation for request_threaded_irq() for details.
 */
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
```
이 함수의 매개변수는 다음 정보들을 전달한다:
- `unsigned int irq` : 인터럽트 번호
- `irq_handler_t handler` : 인터럽트가 발생하면 호출될 인터럽트 핸들러의 주소
- `unsigned long flags` : 인터럽트의 속성 플래그
- `const char *name` : 인터럽트 이름
- `void *dev` : 인터럽트 핸들러에 전달하는 매개변수[^1]

`request_irq()` 함수는 내부적으로 `request_threaded_irq()` 함수를 호출하는 것 말고는 하는 일이 없다. 그러니 `request_threaded_irq()` 함수를 살펴보자.
```C

```


[^1]: 일반적으로는 디바이스 드라이버를 제어하는 구조체 주소를 전달한다. 디바이스 드라이버와 인터럽트 핸들러를 연결하는 인터페이스로 볼 수 있다.