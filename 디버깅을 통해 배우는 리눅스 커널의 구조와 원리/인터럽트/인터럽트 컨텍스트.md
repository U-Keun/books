인터럽트 컨텍스트란 현재 실행 중인 프로세스가 현재 인터럽트를 처리하고 있다는 것으로 이해할 수 있다. '컨텍스트'라는 용어에 대해 좀 더 알아보자.

컨텍스트란 '프로세스 실행 그 자체'를 의미하고, 현재 실행 중인 프로세스 정보를 담고 있는 레지스터 세트와 대응된다. 여기서 레지스터 세트는 `cpu_context_save` 구조체를 의미한다. 
```C
// https://github.com/raspberrypi/linux/tree/rpi-6.6.y/arch/arm/include/asm/thread_info.h
...
struct cpu_context_save {
	__u32	r4;
	__u32	r5;
	__u32	r6;
	__u32	r7;
	__u32	r8;
	__u32	r9;
	__u32	sl;
	__u32	fp;
	__u32	sp;
	__u32	pc;
	__u32	extra[2];		/* Xscale 'acc' register, etc */
};
...
```
위의 구조체는 프로세스 스택의 최상단 주소에 위치한 `thread_info` 구조체의 `cpu_context` 필드에 저장된다. 

다시 정리해보면, 인터럽트 컨텍스트는 현재 실행 중인 프로세스가 인터럽트와 관련된 레지스터 세트라면 인터럽트 컨텍스트인 것이다. 인터럽트 핸들러가 실행 중이든, 인터럽트 핸들러에서 호출된 서브 함수 중 하나가 실행 중이든 레지스터 세트가 인터럽트와 관련된 레지스터 세트라면 인터럽트 컨텍스트인 것이다.

###### `in_interrupt()` 함수
`in_interrupt()` 함수는 현재 실행 중인 코드가 인터럽트 컨텍스트 구간인지 확인하는 함수이다. 이 함수는 인터럽트 컨텍스트이면 `true`, 그렇지 않으면 `false`를 반환하는데, 디바이스 드라이버 코드에서 인터럽트 컨텍스트 조건에서만 동작하도록 하는 데에 쓰인다.
```C
...
idata = kmalloc(sizeof(*idata), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
...
```
위의 코드는 인터럽트를 처리하는 도중에 빠르게 메모리를 할당하는 코드이다. 이외에도 인터럽트 처리 중, 치명적인 오류가 발생했을 때 패닉을 유발시키는 방식으로도 사용된다.

실제 코드를 보자.
```C
// https://github.com/raspberrypi/linux/tree/rpi-6.6.y/include/linux/preempt.h
...
/*
 * These macro definitions avoid redundant invocations of preempt_count()
 * because such invocations would result in redundant loads given that
 * preempt_count() is commonly implemented with READ_ONCE().
 */

#define nmi_count()	(preempt_count() & NMI_MASK)
#define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
#ifdef CONFIG_PREEMPT_RT
# define softirq_count()	(current->softirq_disable_cnt & SOFTIRQ_MASK)
# define irq_count()		((preempt_count() & (NMI_MASK | HARDIRQ_MASK)) | softirq_count())
#else
# define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
# define irq_count()		(preempt_count() & (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_MASK))
#endif
...
#define in_interrupt()		(irq_count())
...

// https://github.com/raspberrypi/linux/tree/rpi-6.6.y/include/asm-generic/preempt/h
...
static __always_inline int preempt_count(void)
{
	return READ_ONCE(current_thread_info()->preempt_count);
}
...

// https://github.com/raspberrypi/linux/tree/081eebdeccfd12e0aaba4b64c9f87b608777913b/arch/arc/include/asm/thread_info.h
...
static inline __attribute_const__ struct thread_info *current_thread_info(void)
{
	register unsigned long sp asm("sp");
	return (struct thread_info *)(sp & ~(THREAD_SIZE - 1));
}
...
```
`in_interrupt()` 함수는 중첩 매크로로 정의되어 있고, `preempt_count()` 함수를 호출하고, `preempt_count()` 함수는 `current_thread_info()` 함수를 호출한다. 다시 말하면, 현재 실행 중인 스레드의 정보에서 `preempt_count` 값을 가져와서 몇 개의 비트 마스크와 연산을 한 뒤, 해당 값을 반환한다. 

`preempt_count` 값은 아래와 같이 비트 필드에 정보가 저장되어 있다. 조금 자세히 살펴보자.
![[스크린샷 2025-02-14 오전 11.58.21.png|center|700]]
- Reschedule needed : 스케줄링을 다시 해야 한다는 표시이다. `preemptive_count` 값이 음수인 경우이다.
- 

